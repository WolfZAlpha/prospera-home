All of the files and code in here belong to the directory: homepage/src/pages/AugmentedReality

The structure of defining the files within this document is like this:

"Filepath"

"Code for file:"

```
code
```

Files separated by: "---------------------------------------------------------"

Let's Begin

------------------------------------------------------------------------------------

File: homepage/src/pages/AugmentedReality/components/Desktop/index.js

Code For File:

```
import React from "react";
import { Box } from "@mui/material";
import { styled } from "@mui/material/styles";
import PropTypes from "prop-types";

const DesktopContainer = styled(Box)(({ theme }) => ({
  height: "100vh",
  width: "100vw",
  background: `linear-gradient(135deg, ${theme.palette.background.default} 0%, ${theme.palette.primary.dark} 100%)`,
  overflow: "hidden",
  position: "relative",
}));

const Desktop = ({ children }) => {
  return <DesktopContainer>{children}</DesktopContainer>;
};

export default Desktop;

Desktop.propTypes = {
  children: PropTypes.node.isRequired,
};
```

-------------------------------------------------------------------------

File: homepage/src/pages/AugmentedReality/components/Emails/index.js

Code For File:

```
/** 
=========================================================
* PROSPERA DEFI PLATFORM - v1.0.0
=========================================================

* Copyright 2024 PROSPERA DEFI (https://www.prosperadefi.com/)

* Design and Coded by Z

=========================================================

* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the PROSPERA DEFI PLATFORM.
*/

// @mui material components
import Card from "@mui/material/Card";
import Tooltip from "@mui/material/Tooltip";

// PROSPERA DEFI PLATFORM React components
import MKBox from "components/MKBox";
import MKTypography from "components/MKTypography";

function Emails() {
  return (
    <Card>
      <MKBox display="flex" justifyContent="space-between" p={3} lineHeight={1}>
        <MKTypography variant="body2" color="text">
          Emails (21)
        </MKTypography>
        <Tooltip title="Check your emails" placement="top">
          <MKBox component="a" href="#">
            <MKTypography variant="body2" fontWeight="regular">
              Check
            </MKTypography>
          </MKBox>
        </Tooltip>
      </MKBox>
    </Card>
  );
}

export default Emails;
```
----------------------------------------------------------------------------


File: homepage/src/pages/AugmentedReality/components/MediaPlayer/index.js

Code For File:

```
/** 
=========================================================
* PROSPERA DEFI PLATFORM - v1.0.0
=========================================================

* Copyright 2024 PROSPERA DEFI (https://www.prosperadefi.com/)

* Design and Coded by Z

=========================================================

* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the PROSPERA DEFI PLATFORM.
*/

// @mui material components
import Card from "@mui/material/Card";
import Icon from "@mui/material/Icon";
import Tooltip from "@mui/material/Tooltip";

// PROSPERA DEFI PLATFORM React components
import MKBox from "components/MKBox";
import MKTypography from "components/MKTypography";
import MKButton from "components/MKButton";

function MediaPlayer() {
  const bgImage =
    "https://images.unsplash.com/photo-1470813740244-df37b8c1edcb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=600&q=80";

  const mediaPlayerButtonStyles = ({ functions: { pxToRem } }) => ({
    width: pxToRem(46),
    height: pxToRem(46),
    minWidth: pxToRem(46),
    minHeight: pxToRem(46),
    mr: 1,
  });

  return (
    <Card
      sx={({ functions: { linearGradient, rgba }, palette: { gradients } }) => ({
        backgroundImage: `${linearGradient(
          rgba(gradients.dark.main, 0.85),
          rgba(gradients.dark.state, 0.85)
        )}, url(${bgImage})`,
        backgroundSize: "cover",
        backgroundPosition: "center",
      })}
    >
      <MKBox p={3} position="relative" lineHeight={0}>
        <MKTypography variant="h5" color="white" fontWeight="medium">
          Some Kind Of Blues
        </MKTypography>
        <MKTypography variant="button" color="white" fontWeight="regular">
          Deftones
        </MKTypography>
        <MKBox display="flex" mt={6} pt={1}>
          <MKBox display="flex" alignItems="center" justifyContent="center">
            <Tooltip title="Prev" placement="top">
              <MKButton
                variant="outlined"
                size="large"
                circular
                iconOnly
                sx={mediaPlayerButtonStyles}
              >
                <Icon>skip_previous</Icon>
              </MKButton>
            </Tooltip>
            <Tooltip title="Pause" placement="top">
              <MKButton
                variant="outlined"
                size="large"
                circular
                iconOnly
                sx={mediaPlayerButtonStyles}
              >
                <Icon>play_arrow</Icon>
              </MKButton>
            </Tooltip>
            <Tooltip title="Next" placement="top">
              <MKButton
                variant="outlined"
                size="large"
                circular
                iconOnly
                sx={mediaPlayerButtonStyles}
              >
                <Icon>skip_next</Icon>
              </MKButton>
            </Tooltip>
          </MKBox>
        </MKBox>
      </MKBox>
    </Card>
  );
}

export default MediaPlayer;
```
----------------------------------------------------------------------


File: homepage/src/pages/AugmentedReality/components/Messages/index.js

Code For File:

```
/** 
=========================================================
* PROSPERA DEFI PLATFORM - v1.0.0
=========================================================

* Copyright 2024 PROSPERA DEFI (https://www.prosperadefi.com/)

* Design and Coded by Z

=========================================================

* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the PROSPERA DEFI PLATFORM.
*/

// @mui material components
import Card from "@mui/material/Card";
import Tooltip from "@mui/material/Tooltip";

// PROSPERA DEFI PLATFORM React components
import MKBox from "components/MKBox";
import MKTypography from "components/MKTypography";
import MKAvatar from "components/MKAvatar";

// Images
import team1 from "assets/images/team-1.jpg";
import team2 from "assets/images/team-2.jpg";
import team3 from "assets/images/team-3.jpg";
import team4 from "assets/images/team-4.jpg";

function Messages() {
  const messagesAvatarStyles = {
    border: ({ borders: { borderWidth }, palette: { white } }) =>
      `${borderWidth[2]} solid ${white.main}`,
    cursor: "pointer",
    position: "relative",
    ml: -1.5,

    "&:hover, &:focus": {
      zIndex: "10",
    },
  };

  return (
    <Card>
      <MKBox display="flex" alignItems="center" justifyContent="space-between" p={3}>
        <MKTypography variant="body2" color="text">
          Messages
        </MKTypography>
        <MKBox display="flex">
          <Tooltip title="2 New Messages" placement="top">
            <MKAvatar src={team1} alt="team-1" size="sm" sx={messagesAvatarStyles} />
          </Tooltip>
          <Tooltip title="1 New Messages" placement="top">
            <MKAvatar src={team2} alt="team-2" size="sm" sx={messagesAvatarStyles} />
          </Tooltip>
          <Tooltip title="13 New Messages" placement="top">
            <MKAvatar src={team3} alt="team-3" size="sm" sx={messagesAvatarStyles} />
          </Tooltip>
          <Tooltip title="7 New Messages" placement="top">
            <MKAvatar src={team4} alt="team-4" size="sm" sx={messagesAvatarStyles} />
          </Tooltip>
        </MKBox>
      </MKBox>
    </Card>
  );
}

export default Messages;

```

---------------------------------------------------------------------------

File: homepage/src/pages/AugmentedReality/components/Navbar/index.js

Code For File:

```
import React from "react";
import { Box, IconButton, Tooltip } from "@mui/material";
import { styled } from "@mui/material/styles";
import FormatListBulletedIcon from "@mui/icons-material/FormatListBulleted";
import AssignmentIcon from "@mui/icons-material/Assignment";
import SmartToyIcon from "@mui/icons-material/SmartToy";
import ChatIcon from "@mui/icons-material/Chat";
import MusicNoteIcon from "@mui/icons-material/MusicNote";
import EmailIcon from "@mui/icons-material/Email";
import CloudIcon from "@mui/icons-material/Cloud";
import DashboardIcon from "@mui/icons-material/Dashboard";
import PropTypes from "prop-types";

const NavbarContainer = styled(Box)(({ theme }) => ({
  position: "fixed",
  bottom: theme.spacing(2),
  left: "50%",
  transform: "translateX(-50%)",
  display: "flex",
  backgroundColor: "rgba(255, 255, 255, 0.1)",
  backdropFilter: "blur(10px)",
  borderRadius: theme.shape.borderRadius * 2,
  padding: theme.spacing(1),
  boxShadow: theme.shadows[10],
  zIndex: 1000,
}));

const NavItem = styled(IconButton)(({ theme }) => ({
  color: theme.palette.common.white,
  "&:hover": {
    backgroundColor: "rgba(255, 255, 255, 0.1)",
  },
}));

const Navbar = ({ onItemClick, onDashboardClick }) => {
  return (
    <NavbarContainer>
      <Tooltip title="To-Do List">
        <NavItem onClick={() => onItemClick("todoList")}>
          <FormatListBulletedIcon />
        </NavItem>
      </Tooltip>
      <Tooltip title="To-Do Card">
        <NavItem onClick={() => onItemClick("todoCard")}>
          <AssignmentIcon />
        </NavItem>
      </Tooltip>
      <Tooltip title="OmniRobot">
        <NavItem onClick={() => onItemClick("omniRobot")}>
          <SmartToyIcon />
        </NavItem>
      </Tooltip>
      <Tooltip title="Chat">
        <NavItem onClick={() => onItemClick("chat")}>
          <ChatIcon />
        </NavItem>
      </Tooltip>
      <Tooltip title="Media Player">
        <NavItem onClick={() => onItemClick("mediaPlayer")}>
          <MusicNoteIcon />
        </NavItem>
      </Tooltip>
      <Tooltip title="Emails">
        <NavItem onClick={() => onItemClick("emails")}>
          <EmailIcon />
        </NavItem>
      </Tooltip>
      <Tooltip title="Weather">
        <NavItem onClick={() => onItemClick("weather")}>
          <CloudIcon />
        </NavItem>
      </Tooltip>
      <Tooltip title="Dashboard">
        <NavItem onClick={onDashboardClick}>
          <DashboardIcon />
        </NavItem>
      </Tooltip>
    </NavbarContainer>
  );
};

export default Navbar;

Navbar.propTypes = {
  onItemClick: PropTypes.func.isRequired,
  onDashboardClick: PropTypes.func.isRequired,
};
```

--------------------------------------------------------------------


File: homepage/src/pages/AugmentedReality/components/omnRobot/OmniRobot.js

Code For File:

```
import React, { useEffect, useRef } from "react";
import * as THREE from "three";
import { gsap } from "gsap";
import { DragControls } from "three/examples/jsm/controls/DragControls";
import PropTypes from "prop-types";

const OmniRobot = ({ onPositionChange }) => {
  const mountRef = useRef(null);
  const robotRef = useRef(null);
  const particleSystemRef = useRef(null); // This was missing in the previous code
  const dragging = useRef(false);

  useEffect(() => {
    let scene,
      camera,
      renderer,
      robot,
      quantumCore,
      dataField,
      nanoSurface,
      energyConduits,
      temporalDistortion,
      aiSynapses,
      dimensionalPhasing,
      thoughtParticles,
      particleSystem;
    let clock = new THREE.Clock();
    let mixer;
    let dragControls;
    let animationFrameId;

    const containerWidth = window.innerWidth / 2;
    const containerHeight = window.innerHeight / 2;

    const init = () => {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, containerWidth / containerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(containerWidth, containerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      mountRef.current.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0x00ffff, 1, 100);
      pointLight.position.set(0, 10, 10);
      scene.add(pointLight);

      robot = new THREE.Group();
      scene.add(robot);
      robotRef.current = robot;

      // Scale the robot to 50% of its original size
      robot.scale.set(0.5, 0.5, 0.5);

      quantumCore = createQuantumCore();
      robot.add(quantumCore);

      nanoSurface = createNanoSurface();
      robot.add(nanoSurface);

      dataField = createDataField();
      robot.add(dataField);

      energyConduits = createEnergyConduits();
      robot.add(energyConduits);

      temporalDistortion = createTemporalDistortion();
      scene.add(temporalDistortion);

      aiSynapses = createAISynapses();
      robot.add(aiSynapses);

      dimensionalPhasing = createDimensionalPhasing();
      robot.add(dimensionalPhasing);

      thoughtParticles = createThoughtParticles();
      robot.add(thoughtParticles);

      particleSystem = createParticleSystem();
      scene.add(particleSystem);
      particleSystemRef.current = particleSystem;

      camera.position.z = 2.5; // Adjusted to ensure the entire robot is visible

      mixer = new THREE.AnimationMixer(robot);

      // Add drag controls
      dragControls = new DragControls([robot], camera, renderer.domElement);
      dragControls.addEventListener("dragstart", () => {
        dragging.current = true;
        robot.position.z = 0; // Ensure the robot stays at the same depth while dragging
      });
      dragControls.addEventListener("drag", (event) => {
        // Update the particle system with the new position
        updateParticleSystem(event.object.position);
      });
      dragControls.addEventListener("dragend", () => {
        dragging.current = false;
        onPositionChange(robot.position);
      });
    };

    const createQuantumCore = () => {
      const geometry = new THREE.IcosahedronGeometry(0.5, 4);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vNormal = normal;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vec3 color1 = vec3(0.0, 1.0, 1.0);
            vec3 color2 = vec3(1.0, 0.0, 1.0);
            vec3 color = mix(color1, color2, sin(vPosition.x * 10.0 + time) * 0.5 + 0.5);
            
            float intensity = sin(vPosition.x * 20.0 + time * 2.0) * 
                              sin(vPosition.y * 20.0 + time * 3.0) * 
                              sin(vPosition.z * 20.0 + time * 4.0);
            intensity = pow(0.5 + 0.5 * intensity, 2.0);
            
            gl_FragColor = vec4(color * intensity, 1.0);
          }
        `,
        wireframe: true,
      });
      return new THREE.Mesh(geometry, material);
    };

    const createNanoSurface = () => {
      const geometry = new THREE.SphereGeometry(0.7, 64, 64);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vNormal = normal;
            vPosition = position;
            vec3 newPosition = position + normal * (sin(position.x * 20.0 + time) * 0.02);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vec3 color = vec3(0.0, 0.5, 1.0);
            float intensity = pow(0.5 + 0.5 * sin(vPosition.x * 20.0 + vPosition.y * 20.0 + time * 2.0), 2.0);
            gl_FragColor = vec4(color * intensity, 0.7);
          }
        `,
        transparent: true,
      });
      return new THREE.Mesh(geometry, material);
    };

    const createDataField = () => {
      const geometry = new THREE.SphereGeometry(1, 64, 64);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vNormal = normal;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vec3 color = vec3(0.0, 1.0, 1.0);
            float intensity = sin(vPosition.x * 20.0 + time * 2.0) * 
                              sin(vPosition.y * 20.0 + time * 3.0) * 
                              sin(vPosition.z * 20.0 + time * 4.0);
            intensity = pow(0.5 + 0.5 * intensity, 2.0);
            gl_FragColor = vec4(color, intensity * 0.2);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
      });
      return new THREE.Mesh(geometry, material);
    };

    const createEnergyConduits = () => {
      const group = new THREE.Group();
      const conduitCount = 10;

      for (let i = 0; i < conduitCount; i++) {
        const curve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() - 0.5,
            Math.random() - 0.5
          ).multiplyScalar(0.5),
          new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() - 0.5,
            Math.random() - 0.5
          ).multiplyScalar(0.7),
          new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() - 0.5,
            Math.random() - 0.5
          ).multiplyScalar(0.5),
        ]);
        const geometry = new THREE.TubeGeometry(curve, 64, 0.01, 8, false);
        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            
            void main() {
              float energy = sin(vUv.x * 20.0 - time * 5.0) * 0.5 + 0.5;
              vec3 color = mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), energy);
              gl_FragColor = vec4(color, energy);
            }
          `,
          transparent: true,
        });
        const conduit = new THREE.Mesh(geometry, material);
        group.add(conduit);
      }

      return group;
    };

    const createTemporalDistortion = () => {
      const geometry = new THREE.SphereGeometry(2, 64, 64);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vNormal = normal;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vec3 color = vec3(0.5, 0.0, 1.0);
            float distortion = sin(vPosition.x * 10.0 + time) * 
                               sin(vPosition.y * 10.0 + time * 1.1) * 
                               sin(vPosition.z * 10.0 + time * 1.2);
            float intensity = pow(0.2 + 0.2 * distortion, 2.0);
            gl_FragColor = vec4(color, intensity * 0.1);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
      });
      return new THREE.Mesh(geometry, material);
    };

    const createAISynapses = () => {
      const geometry = new THREE.BufferGeometry();
      const material = new THREE.PointsMaterial({
        color: 0x00ffff, // Cyan color
        size: 0.01, // Smaller size
        transparent: true,
        opacity: 0.5, // Increase transparency (lower opacity)
        blending: THREE.AdditiveBlending,
      });

      const particleCount = 500; // Number of particles
      const positions = new Float32Array(particleCount * 3);

      const innerRadius = 0.6; // Just outside the quantum core
      const outerRadius = 1.0; // Inside the data field

      for (let i = 0; i < particleCount; i++) {
        const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
        const theta = Math.random() * Math.PI * 2; // Azimuthal angle
        const phi = Math.acos(Math.random() * 2 - 1); // Polar angle

        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = radius * Math.cos(phi);
      }

      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      return new THREE.Points(geometry, material);
    };

    const createDimensionalPhasing = () => {
      const geometry = new THREE.SphereGeometry(0.8, 32, 32);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vNormal = normal;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vec3 color = vec3(1.0, 0.5, 1.0);
            float phase = sin(vPosition.x * 10.0 + time * 2.0) * 
                          sin(vPosition.y * 10.0 + time * 3.0) * 
                          sin(vPosition.z * 10.0 + time * 4.0);
            float intensity = pow(0.5 + 0.5 * phase, 2.0);
            gl_FragColor = vec4(color, intensity * 0.5);
          }
        `,
        transparent: true,
      });
      return new THREE.Mesh(geometry, material);
    };

    const createThoughtParticles = () => {
      const geometry = new THREE.BufferGeometry();
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
            attribute float size;
            uniform float time;
            varying vec3 vColor;
            
            void main() {
              vColor = color;
              vec3 pos = position;
              
              // Orbital motion for a flat ring (Saturn-like)
              float angle = time * 0.1 + atan(pos.x, pos.z); // Slow rotation
              float radius = length(vec2(pos.x, pos.z));
              pos.x = cos(angle) * radius;
              pos.z = sin(angle) * radius;
      
              vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
              gl_PointSize = size * (300.0 / -mvPosition.z);
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
        fragmentShader: `
            uniform float time;
            varying vec3 vColor;
            
            void main() {
              float d = distance(gl_PointCoord, vec2(0.5));
              if(d > 0.5) discard;
              gl_FragColor = vec4(vColor, 1.0 - (d * 2.0));
            }
          `,
        transparent: true,
        blending: THREE.AdditiveBlending,
      });

      const particleCount = 200; // Increased for denser rings
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);

      const innerRadius = 0.8; // Inner edge of the rings
      const outerRadius = 1.2; // Outer edge of the rings

      for (let i = 0; i < particleCount; i++) {
        const radius = innerRadius + Math.random() * (outerRadius - innerRadius); // Spread particles between inner and outer radius
        const theta = Math.random() * Math.PI * 2;

        positions[i * 3] = radius * Math.cos(theta);
        positions[i * 3 + 1] = Math.random() * 0.02 - 0.01; // Keep particles within a thin plane
        positions[i * 3 + 2] = radius * Math.sin(theta);

        colors[i * 3] = 0;
        colors[i * 3 + 1] = 1;
        colors[i * 3 + 2] = 1;

        sizes[i] = Math.random() * 0.01 + 0.001; // Tiny particles
      }

      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

      return new THREE.Points(geometry, material);
    };

    const createParticleSystem = () => {
      const particleCount = 300; // Reduced particle count for subtle effect
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);

      // Initialize particle positions and velocities
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = positions[i * 3 + 1] = positions[i * 3 + 2] = 0;
        velocities[i * 3] = (Math.random() - 0.5) * 0.05;
        velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.05;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.05;
      }

      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute("velocity", new THREE.BufferAttribute(velocities, 3));

      const material = new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 0.02, // Smaller size for subtle effect
        transparent: true,
        opacity: 0.4, // Lower opacity for subtle effect
        blending: THREE.AdditiveBlending,
      });

      const particleSystem = new THREE.Points(geometry, material);
      return particleSystem;
    };

    const updateParticleSystem = (position) => {
      const positions = particleSystemRef.current.geometry.attributes.position.array;
      const velocities = particleSystemRef.current.geometry.attributes.velocity.array;

      // Update particle positions based on velocities
      for (let i = 0; i < positions.length; i += 3) {
        positions[i] += velocities[i];
        positions[i + 1] += velocities[i + 1];
        positions[i + 2] += velocities[i + 2];

        // If the particle is too far away, reset it near the robot
        if (Math.random() > 0.98) {
          // Increased likelihood of resetting for more subtle effect
          positions[i] = position.x;
          positions[i + 1] = position.y;
          positions[i + 2] = position.z;
        }
      }

      particleSystemRef.current.geometry.attributes.position.needsUpdate = true;
    };

    const animate = () => {
      animationFrameId = requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const elapsedTime = clock.getElapsedTime();

      // Update all shader uniforms
      robot.traverse((child) => {
        if (child.material && child.material.uniforms) {
          child.material.uniforms.time.value = elapsedTime;
        }
      });

      // Rotate the entire robot slowly
      robot.rotation.y += 0.001;

      // Animate quantum core
      quantumCore.scale.x = 1 + Math.sin(elapsedTime * 2) * 0.1;
      quantumCore.scale.y = 1 + Math.sin(elapsedTime * 2.5) * 0.1;
      quantumCore.scale.z = 1 + Math.sin(elapsedTime * 3) * 0.1;

      // Animate dimensional phasing
      dimensionalPhasing.material.opacity = 0.5 + Math.sin(elapsedTime * 2) * 0.3;

      // Animate thought particles
      thoughtParticles.material.uniforms.time.value = elapsedTime;

      // Update the particle system
      if (dragging.current) {
        updateParticleSystem(robot.position);
      }

      // Update the animation mixer
      if (mixer) {
        mixer.update(delta);
      }

      renderer.render(scene, camera);
    };

    const handleResize = () => {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
    };

    init();
    animate();

    // Initial animation
    gsap.from(robot.position, {
      y: -5, // Adjusted for the new scale
      duration: 2,
      ease: "power2.out",
      onComplete: () => {
        gsap.to(robot.position, {
          y: "+=0.1", // Adjusted for the new scale
          duration: 1.5,
          yoyo: true,
          repeat: -1,
          ease: "sine.inOut",
        });
      },
    });

    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("resize", handleResize);
      cancelAnimationFrame(animationFrameId);
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      // Dispose of Three.js objects
      scene.traverse((object) => {
        if (object.geometry) object.geometry.dispose();
        if (object.material) {
          if (Array.isArray(object.material)) {
            object.material.forEach((material) => material.dispose());
          } else {
            object.material.dispose();
          }
        }
      });
      renderer.dispose();
    };
  }, [onPositionChange]);

  return (
    <div
      ref={mountRef}
      style={{
        position: "relative",
        width: "100%",
        height: "100%",
        pointerEvents: "auto",
        zIndex: 1000,
      }}
    />
  );
};

OmniRobot.propTypes = {
  onPositionChange: PropTypes.func.isRequired,
};

export default OmniRobot;
```

------------------------------------------------------------------------


File: homepage/src/pages/AugmentedReality/components/TodoCard/index.js

Code For File:

```
/** 
=========================================================
* PROSPERA DEFI PLATFORM - v1.0.0
=========================================================

* Copyright 2024 PROSPERA DEFI (https://www.prosperadefi.com/)

* Design and Coded by Z

=========================================================

* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the PROSPERA DEFI PLATFORM.
*/

// @mui material components
import Icon from "@mui/material/Icon";
import Tooltip from "@mui/material/Tooltip";

// PROSPERA DEFI PLATFORM React components
import MKBox from "components/MKBox";
import MKTypography from "components/MKTypography";

function TodoCard() {
  return (
    <MKBox bgColor="dark" variant="gradient" borderRadius="xl" shadow="lg">
      <MKBox p={3}>
        <MKBox display="flex" justifyContent="space-between">
          <MKTypography variant="h5" color="white">
            To Do
          </MKTypography>
          <MKBox textAlign="center" lineHeight={1}>
            <MKTypography variant="h1" color="white" fontWeight="bold">
              7
            </MKTypography>
            <MKTypography variant="button" color="white" fontWeight="regular">
              items
            </MKTypography>
          </MKBox>
        </MKBox>
        <MKTypography variant="body2" color="white" fontWeight="regular">
          Shopping
        </MKTypography>
        <MKTypography variant="body2" color="white" fontWeight="regular">
          Meeting
        </MKTypography>
      </MKBox>
      <Tooltip title="Show More" placement="top" sx={{ cursor: "pointer" }}>
        <MKBox textAlign="center" color="white" py={0.5} lineHeight={0}>
          <Icon sx={{ fontWeight: "bold" }} color="inherit" fontSize="default">
            keyboard_arrow_down
          </Icon>
        </MKBox>
      </Tooltip>
    </MKBox>
  );
}

export default TodoCard;
```

------------------------------------------------------------------------


File: homepage/src/pages/AugmentedReality/components/TodoList/index.js

Code For File:

```
/** 
=========================================================
* PROSPERA DEFI PLATFORM - v1.0.0
=========================================================

* Copyright 2024 PROSPERA DEFI (https://www.prosperadefi.com/)

* Design and Coded by Z

=========================================================

* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the PROSPERA DEFI PLATFORM.
*/

// @mui material components
import Card from "@mui/material/Card";
import Divider from "@mui/material/Divider";
import Icon from "@mui/material/Icon";
import Tooltip from "@mui/material/Tooltip";

// PROSPERA DEFI PLATFORM React components
import MKBox from "components/MKBox";
import MKTypography from "components/MKTypography";

function TodoList() {
  return (
    <Card sx={{ height: "100%", overflow: "hidden" }}>
      <MKBox p={3}>
        <MKBox display="flex" lineHeight={1}>
          <MKBox mr={2}>
            <MKTypography variant="h6" fontWeight="medium">
              08:00
            </MKTypography>
          </MKBox>
          <MKBox>
            <MKTypography variant="h6" fontWeight="medium">
              Synk up with Mark
            </MKTypography>
            <MKTypography variant="button" fontWeight="regular" color="secondary">
              Hangouts
            </MKTypography>
          </MKBox>
        </MKBox>
        <Divider />
        <MKBox display="flex" lineHeight={0}>
          <MKBox mr={2}>
            <MKTypography variant="h6" fontWeight="medium">
              09:30
            </MKTypography>
          </MKBox>
          <MKBox>
            <MKTypography variant="h6" fontWeight="medium">
              Gym
            </MKTypography>
            <MKTypography variant="button" fontWeight="regular" color="secondary">
              World Class
            </MKTypography>
          </MKBox>
        </MKBox>
        <Divider />
        <MKBox display="flex" lineHeight={1}>
          <MKBox mr={2}>
            <MKTypography variant="h6" fontWeight="medium">
              11:00
            </MKTypography>
          </MKBox>
          <MKBox>
            <MKTypography variant="h6" fontWeight="medium">
              Design Review
            </MKTypography>
            <MKTypography variant="button" fontWeight="regular" color="secondary">
              Zoom
            </MKTypography>
          </MKBox>
        </MKBox>
      </MKBox>
      <MKBox bgColor="grey-100" mt="auto">
        <Tooltip title="Show More" placement="top" sx={{ cursor: "pointer" }}>
          <MKBox textAlign="center" py={0.5} color="info" lineHeight={0}>
            <Icon sx={{ fontWeight: "bold" }} color="inherit" fontSize="default">
              keyboard_arrow_down
            </Icon>
          </MKBox>
        </Tooltip>
      </MKBox>
    </Card>
  );
}

export default TodoList;
```

------------------------------------------------------------------------


File: homepage/src/pages/AugmentedReality/components/WeatherWidget/index.js

Code For File:

```
import React from "react";
import { Box, Typography } from "@mui/material";
import MKBox from "components/MKBox";
import PropTypes from "prop-types";

const WeatherWidget = ({ temperature, condition, icon }) => {
  return (
    <MKBox display="flex" flexDirection="column" alignItems="center">
      <Typography variant="h2">{temperature}</Typography>
      <Typography variant="h6" textTransform="uppercase">
        {condition}
      </Typography>
      <Box component="img" src={icon} width="30%" mt={2} />
    </MKBox>
  );
};

export default WeatherWidget;

WeatherWidget.propTypes = {
  temperature: PropTypes.string.isRequired,
  condition: PropTypes.string.isRequired,
  icon: PropTypes.string.isRequired,
};
```

------------------------------------------------------------------------


File: homepage/src/pages/AugmentedReality/components/Window/index.js

Code For File:

```
import React, { useState } from "react";
import { Box, IconButton, Typography } from "@mui/material";
import { styled } from "@mui/material/styles";
import CloseIcon from "@mui/icons-material/Close";
import Draggable from "react-draggable";
import PropTypes from "prop-types";

const WindowContainer = styled(Box)(({ theme }) => ({
  backgroundColor: theme.palette.background.paper,
  borderRadius: theme.shape.borderRadius,
  boxShadow: theme.shadows[10],
  overflow: "hidden",
  position: "absolute",
  minWidth: 300,
  minHeight: 200,
}));

const WindowHeader = styled(Box)(({ theme }) => ({
  backgroundColor: theme.palette.primary.main,
  color: theme.palette.primary.contrastText,
  padding: theme.spacing(1),
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  cursor: "move",
}));

const Window = ({ title, onClose, children }) => {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  const handleDrag = (e, data) => {
    setPosition({ x: data.x, y: data.y });
  };

  return (
    <Draggable handle=".window-header" position={position} onDrag={handleDrag}>
      <WindowContainer>
        <WindowHeader className="window-header">
          <Typography variant="subtitle1">{title}</Typography>
          <IconButton size="small" onClick={onClose} sx={{ color: "inherit" }}>
            <CloseIcon />
          </IconButton>
        </WindowHeader>
        <Box p={2}>{children}</Box>
      </WindowContainer>
    </Draggable>
  );
};

export default Window;

Window.propTypes = {
  title: PropTypes.string.isRequired,
  onClose: PropTypes.func.isRequired,
  children: PropTypes.node.isRequired,
};
```

------------------------------------------------------------------------


File: homepage/src/pages/AugmentedReality/index.js

Code For File:

```
import React, { useState, useEffect, useContext } from "react";
import { useNavigate } from "react-router-dom";

// PROSPERA DEFI PLATFORM React components
import MKBox from "components/MKBox";
import MKTypography from "components/MKTypography";
import MKButton from "components/MKButton";

// PROSPERA DEFI PLATFORM React examples
import DefaultNavbar from "examples/Navbars/DefaultNavbar";
import DefaultFooter from "examples/Footers/DefaultFooter";

// AugmentedReality page components
import TodoList from "pages/AugmentedReality/components/TodoList";
import TodoCard from "pages/AugmentedReality/components/TodoCard";
import Emails from "pages/AugmentedReality/components/Emails";
import MediaPlayer from "pages/AugmentedReality/components/MediaPlayer";
import Messages from "pages/AugmentedReality/components/Messages";
import OmniRobot from "pages/AugmentedReality/components/omnRobot/OmniRobot";
import WeatherWidget from "pages/AugmentedReality/components/WeatherWidget";

// New components
import Navbar from "./components/Navbar";
import Desktop from "./components/Desktop";
import Window from "./components/Window";

// Routes
import routes from "routes";
import footerRoutes from "footer.routes";

// Images
import bgImage from "assets/images/backgrounds/DesktopBackgrounds/Mountains/blackandwhitemountains.jpg";
import sunCloud from "assets/images/small-logos/icon-sun-cloud.png";

// Contexts
import { AuthContext } from "contexts/AuthContext";
import { WalletContext } from "contexts/WalletContext";
import { BetaContext } from "contexts/BetaContext";

// API services
import { fetchUserData, checkTokenHolding } from "services/api";

function AugmentedReality() {
  const navigate = useNavigate();
  const { user, loading: authLoading, checkAuth } = useContext(AuthContext);
  const { wallet, connectWallet } = useContext(WalletContext);
  const { isBetaMode, requestWhitelist } = useContext(BetaContext);

  const [userData, setUserData] = useState(null);
  const [openWindows, setOpenWindows] = useState({});
  const [robotPosition, setRobotPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const initializeComponent = async () => {
      console.log("Initializing AugmentedReality component");
      console.log("Auth loading:", authLoading);
      console.log("User:", user);

      if (!user) {
        console.log("No user found, re-checking authentication");
        try {
          await checkAuth();
        } catch (error) {
          console.error("Authentication check failed:", error);
          navigate("/login");
          return;
        }
      }

      if (user) {
        console.log("User authenticated, loading user data");
        try {
          const data = await fetchUserData(user.id);
          console.log("User data loaded:", data);
          setUserData(data.data.attributes);

          setRobotPosition({
            x: window.innerWidth * 0.1,
            y: window.innerHeight - 150,
          });
        } catch (error) {
          console.error("Error fetching user data:", error);
          // If there's an error fetching user data, use the data from AuthContext
          setUserData(user);
        }
      }

      setIsLoading(false);
    };

    initializeComponent();
  }, [user, authLoading, checkAuth, navigate]);

  const toggleWindow = (appName) => {
    setOpenWindows((prev) => ({ ...prev, [appName]: !prev[appName] }));
  };

  const handleDashboardClick = async () => {
    if (wallet && (await checkTokenHolding(wallet.address))) {
      window.location.href = "https://dashboard.prosperadefi.com";
    } else {
      alert("You need to hold $PROS tokens to access the dashboard.");
    }
  };

  const handleRobotPositionChange = (newPosition) => {
    setRobotPosition({
      x: newPosition.x * (window.innerWidth / 2),
      y: -newPosition.y * (window.innerHeight / 2),
    });
  };

  const handleDragStart = () => {
    setIsDragging(true);
    document.body.style.cursor = "grabbing";
  };

  const handleDragEnd = () => {
    setIsDragging(false);
    document.body.style.cursor = "grab";
  };

  const handleMouseMove = (e) => {
    if (isDragging) {
      setRobotPosition({
        x: e.clientX,
        y: e.clientY,
      });
    }
  };

  const handleRequestWhitelist = async () => {
    if (!wallet) {
      await connectWallet();
    }
    if (wallet) {
      await requestWhitelist(wallet.address);
    } else {
      alert("Please connect your wallet to request whitelist access.");
    }
  };

  console.log("Rendering AugmentedReality component");
  console.log("Auth loading:", authLoading);
  console.log("User:", user);
  console.log("User data:", userData);
  console.log("Beta mode:", isBetaMode);

  if (isLoading || authLoading) {
    console.log("Still loading");
    return (
      <MKBox display="flex" justifyContent="center" alignItems="center" minHeight="100vh">
        <MKTypography variant="h4">Loading...</MKTypography>
      </MKBox>
    );
  }

  if (!user && !userData) {
    console.log("No user found after loading");
    return (
      <MKBox
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="100vh"
        sx={{
          backgroundImage: `url(${bgImage})`,
          backgroundSize: "cover",
          backgroundPosition: "center",
        }}
      >
        <MKBox bgColor="white" borderRadius="xl" shadow="lg" p={4} textAlign="center">
          <MKTypography variant="h4" mb={2}>
            Access Restricted
          </MKTypography>
          <MKTypography variant="body1" mb={3}>
            To access the Augmented Reality page, you must be signed in.
          </MKTypography>
          <MKButton variant="gradient" color="info" onClick={() => navigate("/login")}>
            Sign In
          </MKButton>
        </MKBox>
      </MKBox>
    );
  }

  const currentUserData = userData || user;
  const hasFullAccess =
    ["admin", "co-admin", "prosperaTeam", "kol"].includes(currentUserData.role) ||
    currentUserData.isWhitelisted;

  if (isBetaMode && !hasFullAccess) {
    console.log("User does not have full access in beta mode");
    return (
      <MKBox
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="100vh"
        sx={{
          backgroundImage: `url(${bgImage})`,
          backgroundSize: "cover",
          backgroundPosition: "center",
        }}
      >
        <MKBox bgColor="white" borderRadius="xl" shadow="lg" p={4} textAlign="center">
          <MKTypography variant="h4" mb={2}>
            Beta Access Required
          </MKTypography>
          <MKTypography variant="body1" mb={3}>
            {currentUserData.hasRequestedWhitelist
              ? "Your whitelist request is being processed. Please check back later."
              : "You are not an approved member to access during beta-testing."}
          </MKTypography>
          {!currentUserData.hasRequestedWhitelist && (
            <MKButton variant="gradient" color="info" onClick={handleRequestWhitelist}>
              Request Whitelist Access
            </MKButton>
          )}
        </MKBox>
      </MKBox>
    );
  }

  console.log("Rendering full AugmentedReality component");

  return (
    <>
      <DefaultNavbar
        routes={routes}
        action={{
          type: "external",
          route: "https://www.prosperadefi.com",
          label: "buy now",
          color: "dark",
        }}
      />
      <MKBox
        component="header"
        minHeight="100vh"
        width="100%"
        sx={{
          backgroundImage: ({ functions: { linearGradient, rgba }, palette: { gradients } }) =>
            `${linearGradient(
              rgba(gradients.dark.main, 0.6),
              rgba(gradients.dark.state, 0.6)
            )}, url(${bgImage})`,
          backgroundSize: "cover",
          backgroundPosition: "center",
          display: "grid",
          placeItems: "center",
          position: "relative",
        }}
        onMouseMove={handleMouseMove}
        onMouseUp={handleDragEnd}
      >
        <Desktop>
          {openWindows.todoList && (
            <Window title="To-Do List" onClose={() => toggleWindow("todoList")}>
              <TodoList />
            </Window>
          )}
          {openWindows.todoCard && (
            <Window title="To-Do Card" onClose={() => toggleWindow("todoCard")}>
              <TodoCard />
            </Window>
          )}
          {openWindows.emails && (
            <Window title="Emails" onClose={() => toggleWindow("emails")}>
              <Emails />
            </Window>
          )}
          {openWindows.mediaPlayer && (
            <Window title="Media Player" onClose={() => toggleWindow("mediaPlayer")}>
              <MediaPlayer />
            </Window>
          )}
          {openWindows.messages && (
            <Window title="Messages" onClose={() => toggleWindow("messages")}>
              <Messages />
            </Window>
          )}
          {openWindows.weather && (
            <Window title="Weather" onClose={() => toggleWindow("weather")}>
              <WeatherWidget temperature="28°C" condition="cloudy" icon={sunCloud} />
            </Window>
          )}
        </Desktop>

        <MKBox
          sx={{
            position: "absolute",
            top: robotPosition.y,
            left: robotPosition.x,
            zIndex: 1000,
            cursor: isDragging ? "grabbing" : "grab",
            transform: "translate(-50%, -50%)",
          }}
          onMouseDown={handleDragStart}
        >
          <OmniRobot onPositionChange={handleRobotPositionChange} />
        </MKBox>

        <MKTypography
          variant="body2"
          color="white"
          sx={{
            position: "absolute",
            bottom: 5,
            left: 20,
            zIndex: 1001,
          }}
        >
          Robot Position: X: {robotPosition.x.toFixed(2)}, Y: {robotPosition.y.toFixed(2)}
        </MKTypography>

        <Navbar onItemClick={toggleWindow} onDashboardClick={handleDashboardClick} />
      </MKBox>
      <MKBox pt={6} px={1} mt={6}>
        <DefaultFooter content={footerRoutes} />
      </MKBox>
    </>
  );
}

export default AugmentedReality;
```
