All of the files and code in here belong to the server in the root directory: /server

The structure of defining the files within this document is like this:

"Filepath"

"Code for file:"

```
code
```

Files separated by: "---------------------------------------------------------"

Let's Begin

------------------------------------------------------------------------------------

File: server/src/landing/index.html

Code for file:

```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PROSPERA DEFI</title>

    <link
      href="https://fonts.googleapis.com/css?family=Nunito:200,600"
      rel="stylesheet"
    />
    <style>
      html,
      body {
        background-color: #000;
        color: #636b6f;
        font-family: "Nunito", sans-serif;
        font-weight: 200;
        height: 100vh;
        margin: 0;
      }

      .full-height {
        height: 100vh;
      }

      .flex-center {
        align-items: center;
        display: flex;
        justify-content: center;
      }

      .position-ref {
        position: relative;
      }

      .top-right {
        position: absolute;
        right: 10px;
        top: 18px;
      }

      .content {
        text-align: center;
      }

      .title {
        font-size: 84px;
      }

      .links > a {
        color: #636b6f;
        padding: 0 25px;
        font-size: 13px;
        font-weight: 600;
        letter-spacing: 0.1rem;
        text-decoration: none;
        text-transform: uppercase;
      }

      .m-b-md {
        margin-bottom: 30px;
      }
    </style>
  </head>
  <body>
    <div class="flex-center position-ref full-height">
      <div class="content">
        <div class="title m-b-md">Headless CMS with ExpressJS API:PRO</div>

        <div class="links">
          <a href="https://expressjs.com/" target="_blank">Express.js</a>
          <a href="https://www.mongodb.com/" target="_blank">MongoDB</a>
          <a
            href="https://documenter.getpostman.com/view/8138626/Uze1virp"
            target="_blank"
            >Documentation</a
          >
        </div>
      </div>
    </div>
  </body>
</html>
```

------------------------------------------------------------------------------------

File: server/src/middleware/authMiddleware/index.js

Code for file:

```
import { verifyToken } from "../../services/auth/index.js";
import { userModel } from "../../schemas/user.schema.js";

export const protect = async (req, res, next) => {
  let token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ message: "Not authorized, no token" });
  }

  try {
    const payload = await verifyToken(token);
    if (!payload) {
      return res.status(401).json({ message: "Not authorized, token failed" });
    }
    req.user = await userModel
      .findById(payload.id)
      .select("-password")
      .populate("role");
    next();
  } catch (error) {
    console.error("Token verification error:", error);
    res.status(401).json({ message: "Not authorized, token failed" });
  }
};

export const authorize = (...roles) => {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role.name)) {
      return res
        .status(403)
        .json({ message: "Not authorized to access this route" });
    }
    next();
  };
};
```

------------------------------------------------------------------------------------

File: server/src/mongoose/clearDevDbs.js

Code for file:

```
import mongoose from "mongoose";
import { dbConnect } from "./index.js";
import dotenv from "dotenv";

import { userModel } from "../schemas/user.schema.js";
import { roleModel } from "../schemas/role.schema.js";
import { permissionModel } from "../schemas/permission.schema.js";
import { tagModel } from "../schemas/tag.schema.js";
import { categoryModel } from "../schemas/category.schema.js";
import { itemModel } from "../schemas/item.schema.js";

dotenv.config();

async function clearDevDbs() {
  if (process.env.NODE_ENV === "production") {
    console.error("This script cannot be run in production!");
    process.exit(1);
  }

  dbConnect();
  await roleModel.deleteMany({});
  await permissionModel.deleteMany({});
  await userModel.deleteMany({});
  await tagModel.deleteMany({});
  await categoryModel.deleteMany({});
  await itemModel.deleteMany({});
  console.log("Development DB cleared");
}

clearDevDbs().then(() => {
  mongoose.connection.close();
});
```

------------------------------------------------------------------------------------

File: server/src/mongoose/index.js

Code for file:

```
import mongoose from "mongoose";
import dotenv from "dotenv";

dotenv.config();

export const dbConnect = async () => {
  try {
    if (!process.env.DB_LINK) {
      throw new Error("DB_LINK is not defined in the environment variables");
    }

    await mongoose.connect(process.env.DB_LINK, {
      ssl: true,
      tlsAllowInvalidCertificates: true, // Only use this for testing. Remove in production.
    });
    console.log("MongoDB connection established successfully");
  } catch (error) {
    console.error("MongoDB connection error:", error);
    process.exit(1);
  }

  mongoose.connection.on("error", (err) => {
    console.error("MongoDB connection error:", err);
  });

  mongoose.connection.on("disconnected", () => {
    console.warn("MongoDB disconnected. Attempting to reconnect...");
  });

  mongoose.connection.on("reconnected", () => {
    console.log("MongoDB reconnected");
  });
};

```

------------------------------------------------------------------------------------

File: server/src/mongoose/RessedAction.js

Code for file:

```
import bcrypt from "bcrypt";
import mongoose from "mongoose";
import { dbConnect } from "./index.js";

import { userModel } from "../schemas/user.schema.js";
import { roleModel } from "../schemas/role.schema.js";
import { permissionModel } from "../schemas/permission.schema.js";
import { tagModel } from "../schemas/tag.schema.js";
import { categoryModel } from "../schemas/category.schema.js";
import { itemModel } from "../schemas/item.schema.js";

import dotenv from "dotenv";
dotenv.config();

const ReseedAction = () => {
  async function clear() {
    dbConnect();
    await roleModel.deleteMany({});
    await permissionModel.deleteMany({});
    await userModel.deleteMany({});
    await tagModel.deleteMany({});
    await categoryModel.deleteMany({});
    await itemModel.deleteMany({});
    console.log("DB cleared");
  }

  async function seedDB() {
    // first clear DB
    await clear();

    // crypt default password
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash("secret", salt);
    const admin = new userModel({
      _id: mongoose.Types.ObjectId(1),
      name: "Admin",
      email: "admin@jsonapi.com",
      password: hashPassword,
      created_at: new Date(),
      profile_image: `${process.env.APP_URL_API}/public/images/admin.jpg`,
    });
    const creator = new userModel({
      _id: mongoose.Types.ObjectId(2),
      name: "Creator",
      email: "creator@jsonapi.com",
      password: hashPassword,
      created_at: new Date(),
      profile_image: `${process.env.APP_URL_API}/public/images/creator.jpg`,
    });
    const member = new userModel({
      _id: mongoose.Types.ObjectId(3),
      name: "Member",
      email: "member@jsonapi.com",
      password: hashPassword,
      created_at: new Date(),
      profile_image: `${process.env.APP_URL_API}/public/images/member.jpg`,
    });

    // user permission
    const perm1 = await permissionModel({
      created_at: new Date(),
      name: "view users",
    });
    const perm2 = await permissionModel({
      created_at: new Date(),
      name: "create users",
    });
    const perm3 = await permissionModel({
      created_at: new Date(),
      name: "edit users",
    });
    const perm4 = await permissionModel({
      created_at: new Date(),
      name: "delete users",
    });
    // role permission
    const perm5 = await permissionModel({
      created_at: new Date(),
      name: "view roles",
    });
    const perm6 = await permissionModel({
      created_at: new Date(),
      name: "create roles",
    });
    const perm7 = await permissionModel({
      created_at: new Date(),
      name: "edit roles",
    });
    const perm8 = await permissionModel({
      created_at: new Date(),
      name: "delete roles",
    });
    // permission permissions
    const perm9 = await permissionModel({
      created_at: new Date(),
      name: "view permissions",
    });
    // tag permissions
    const perm10 = await permissionModel({
      created_at: new Date(),
      name: "view tags",
    });
    const perm11 = await permissionModel({
      created_at: new Date(),
      name: "create tags",
    });
    const perm12 = await permissionModel({
      created_at: new Date(),
      name: "edit tags",
    });
    const perm13 = await permissionModel({
      created_at: new Date(),
      name: "delete tags",
    });
    // category permissions
    const perm14 = await permissionModel({
      created_at: new Date(),
      name: "view categories",
    });
    const perm15 = await permissionModel({
      created_at: new Date(),
      name: "create categories",
    });
    const perm16 = await permissionModel({
      created_at: new Date(),
      name: "edit categories",
    });
    const perm17 = await permissionModel({
      created_at: new Date(),
      name: "delete categories",
    });
    // items permissions
    const perm18 = await permissionModel({
      created_at: new Date(),
      name: "view items",
    });
    const perm19 = await permissionModel({
      created_at: new Date(),
      name: "create items",
    });
    const perm20 = await permissionModel({
      created_at: new Date(),
      name: "edit items",
    });
    const perm21 = await permissionModel({
      created_at: new Date(),
      name: "delete items",
    });
    await permissionModel.insertMany([
      perm1,
      perm2,
      perm3,
      perm4,
      perm5,
      perm6,
      perm7,
      perm8,
      perm9,
      perm10,
      perm11,
      perm12,
      perm13,
      perm14,
      perm15,
      perm16,
      perm17,
      perm18,
      perm19,
      perm20,
      perm21,
    ]);

    const roleAdmin = new roleModel({
      _id: mongoose.Types.ObjectId(1),
      name: "admin",
      created_at: new Date(),
      users: [admin],
      permissions: [
        perm1._id,
        perm2._id,
        perm3._id,
        perm4._id,
        perm5._id,
        perm6._id,
        perm7._id,
        perm8._id,
        perm9._id,
        perm10._id,
        perm11._id,
        perm12._id,
        perm13._id,
        perm14._id,
        perm15._id,
        perm16._id,
        perm17._id,
        perm18._id,
        perm19._id,
        perm20._id,
        perm21._id,
      ],
    });
    await roleAdmin.save();
    admin.role = roleAdmin._id;
    await admin.save();
    const roleCreator = new roleModel({
      _id: mongoose.Types.ObjectId(2),
      name: "creator",
      created_at: new Date(),
      users: [creator],
      permissions: [
        perm10._id,
        perm11._id,
        perm12._id,
        perm13._id,
        perm14._id,
        perm15._id,
        perm16._id,
        perm17._id,
        perm18._id,
        perm19._id,
        perm20._id,
        perm21._id,
      ],
    });
    await roleCreator.save();
    creator.role = roleCreator._id;
    await creator.save();
    const roleMember = new roleModel({
      _id: mongoose.Types.ObjectId(3),
      name: "member",
      created_at: new Date(),
      users: [member],
      permissions: [perm10._id, perm11._id, perm15._id, perm18._id],
    });
    await roleMember.save();
    member.role = roleMember._id;
    await member.save();

    const cat1 = new categoryModel({
      name: "Travel",
      description: "Travel ideas for everyone",
      created_at: new Date(),
    });
    const cat2 = new categoryModel({
      name: "Food",
      description: "Our favourite recipes",
      created_at: new Date(),
    });
    const cat3 = new categoryModel({
      name: "Home",
      description: "The latest trends in home decorations",
      created_at: new Date(),
    });
    const cat4 = new categoryModel({
      name: "Fashion",
      description: "Stay in touch with the latest trends",
      created_at: new Date(),
    });
    const cat5 = new categoryModel({
      name: "Health",
      description: "An apple a day keeps the doctor away",
      created_at: new Date(),
    });
    const item1 = new itemModel({
      name: "5 citybreak ideas for this year",
      status: "published",
      excerpt: "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
      description:
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin sit amet nulla nulla. Donec luctus lorem justo, ut ullamcorper eros pellentesque ut. Etiam scelerisque dapibus lorem, vitae maximus ante condimentum quis. Maecenas ac arcu a lacus aliquet elementum posuere id nunc. Curabitur sem lorem, faucibus ac enim ut, vestibulum feugiat ante. Fusce hendrerit leo nibh, nec consectetur nulla venenatis et. Nulla tincidunt neque quam, sit amet tincidunt quam blandit in. Nunc fringilla rutrum tortor, sit amet bibendum augue convallis a. Etiam mauris orci, sollicitudin eu condimentum sed, dictum ut odio. Sed vel ligula in lectus scelerisque ornare.Mauris dolor nisl, finibus eget sem in, ultrices semper libero. Nullam accumsan suscipit tortor, a vestibulum sapien imperdiet quis. Donec pretium mauris quis lectus sodales accumsan. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec tincidunt semper orci eu molestie. Vivamus fermentum enim vitae magna elementum, quis iaculis augue tincidunt. Donec fermentum quam facilisis sem dictum rutrum. Nunc nec urna lectus. Nulla nec ultrices lorem. Integer ac ante massa.",
      image: `${process.env.APP_URL_API}/public/images/product.jpg`,
      is_on_homepage: false,
      date_at: new Date(),
      created_at: new Date(),
    });
    item1.category_id = cat1._id;
    const item2 = new itemModel({
      name: "Top 10 restaurants in Italy",
      status: "published",
      excerpt: "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
      description:
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin sit amet nulla nulla. Donec luctus lorem justo, ut ullamcorper eros pellentesque ut. Etiam scelerisque dapibus lorem, vitae maximus ante condimentum quis. Maecenas ac arcu a lacus aliquet elementum posuere id nunc. Curabitur sem lorem, faucibus ac enim ut, vestibulum feugiat ante. Fusce hendrerit leo nibh, nec consectetur nulla venenatis et. Nulla tincidunt neque quam, sit amet tincidunt quam blandit in. Nunc fringilla rutrum tortor, sit amet bibendum augue convallis a. Etiam mauris orci, sollicitudin eu condimentum sed, dictum ut odio. Sed vel ligula in lectus scelerisque ornare.Mauris dolor nisl, finibus eget sem in, ultrices semper libero. Nullam accumsan suscipit tortor, a vestibulum sapien imperdiet quis. Donec pretium mauris quis lectus sodales accumsan. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec tincidunt semper orci eu molestie. Vivamus fermentum enim vitae magna elementum, quis iaculis augue tincidunt. Donec fermentum quam facilisis sem dictum rutrum. Nunc nec urna lectus. Nulla nec ultrices lorem. Integer ac ante massa.",
      image: `${process.env.APP_URL_API}/public/images/product.jpg`,
      is_on_homepage: false,
      date_at: new Date(),
      created_at: new Date(),
    });
    item2.category_id = cat2._id;
    const item3 = new itemModel({
      name: "Cocktail ideas for your birthday party",
      status: "published",
      excerpt: "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
      description:
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin sit amet nulla nulla. Donec luctus lorem justo, ut ullamcorper eros pellentesque ut. Etiam scelerisque dapibus lorem, vitae maximus ante condimentum quis. Maecenas ac arcu a lacus aliquet elementum posuere id nunc. Curabitur sem lorem, faucibus ac enim ut, vestibulum feugiat ante. Fusce hendrerit leo nibh, nec consectetur nulla venenatis et. Nulla tincidunt neque quam, sit amet tincidunt quam blandit in. Nunc fringilla rutrum tortor, sit amet bibendum augue convallis a. Etiam mauris orci, sollicitudin eu condimentum sed, dictum ut odio. Sed vel ligula in lectus scelerisque ornare.Mauris dolor nisl, finibus eget sem in, ultrices semper libero. Nullam accumsan suscipit tortor, a vestibulum sapien imperdiet quis. Donec pretium mauris quis lectus sodales accumsan. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec tincidunt semper orci eu molestie. Vivamus fermentum enim vitae magna elementum, quis iaculis augue tincidunt. Donec fermentum quam facilisis sem dictum rutrum. Nunc nec urna lectus. Nulla nec ultrices lorem. Integer ac ante massa.",
      image: `${process.env.APP_URL_API}/public/images/product.jpg`,
      is_on_homepage: false,
      date_at: new Date(),
      created_at: new Date(),
    });
    item3.category_id = cat3._id;
    const tag1 = new tagModel({
      name: "Hot",
      color: "#f44336",
      created_at: new Date(),
    });
    const tag2 = new tagModel({
      name: "Trending",
      color: "#9c27b0",
      created_at: new Date(),
    });
    const tag3 = new tagModel({
      name: "New",
      color: "#00bcd4",
      created_at: new Date(),
    });
    tag1.items.push(item1, item3);
    tag2.items.push(item1, item2, item3);
    tag3.items.push(item2, item3);
    cat1.items.push(item1);
    cat2.items.push(item2);
    cat3.items.push(item3);
    await categoryModel.insertMany([cat1, cat2, cat3, cat4, cat5]);
    await tagModel.insertMany([tag1, tag2, tag3]);
    item1.tags.push(tag1);
    item1.tags.push(tag2);
    item2.tags.push(tag3);
    item2.tags.push(tag2);
    item3.tags.push(tag1);
    item3.tags.push(tag2);
    item3.tags.push(tag3);
    await itemModel.insertMany([item1, item2, item3]);

    console.log("DB seeded");
  }

  seedDB();
};

export default ReseedAction;
```

------------------------------------------------------------------------------------

File: server/src/mongoose/seedData.js

Code for file:

```
import bcrypt from "bcrypt";
import mongoose from "mongoose";
import { dbConnect } from "./index.js";

import { userModel } from "../schemas/user.schema.js";
import { roleModel } from "../schemas/role.schema.js";
import { permissionModel } from "../schemas/permission.schema.js";

import dotenv from "dotenv";
dotenv.config();

async function seedDB() {
  // Connect to db
  await dbConnect();

  // Create admin user
  const salt = await bcrypt.genSalt(10);
  const hashPassword = await bcrypt.hash(process.env.ADMIN_PASSWORD, salt);
  const admin = new userModel({
    name: "Admin",
    email: process.env.ADMIN_EMAIL,
    password: hashPassword,
    arbitrumWallet: process.env.ADMIN_WALLET,
    role: "admin",
    created_at: new Date(),
    profile_image: `${process.env.APP_URL_API}/public/images/admin.jpg`,
  });

  // Define all permissions
  const permissions = [
    "view users",
    "create users",
    "edit users",
    "delete users",
    "view roles",
    "create roles",
    "edit roles",
    "delete roles",
    "view permissions",
    "view tags",
    "create tags",
    "edit tags",
    "delete tags",
    "view categories",
    "create categories",
    "edit categories",
    "delete categories",
    "view items",
    "create items",
    "edit items",
    "delete items",
  ];

  // Create permissions
  const createdPermissions = await Promise.all(
    permissions.map((name) =>
      permissionModel.findOneAndUpdate(
        { name },
        { name, created_at: new Date() },
        { upsert: true, new: true }
      )
    )
  );

  // Create role-permission mappings
  const rolePermissions = {
    admin: createdPermissions.map((perm) => perm._id),
    prosperaTeam: createdPermissions
      .filter(
        (perm) => !perm.name.includes("users") && !perm.name.includes("roles")
      )
      .map((perm) => perm._id),
    kol: createdPermissions
      .filter(
        (perm) =>
          perm.name.startsWith("view") ||
          perm.name.includes("create") ||
          perm.name.includes("edit")
      )
      .map((perm) => perm._id),
    user: createdPermissions
      .filter((perm) => perm.name.startsWith("view"))
      .map((perm) => perm._id),
  };

  // Create or update roles
  for (const [roleName, permissions] of Object.entries(rolePermissions)) {
    await roleModel.findOneAndUpdate(
      { name: roleName },
      {
        name: roleName,
        permissions: permissions,
        created_at: new Date(),
        updated_at: new Date(),
      },
      { upsert: true, new: true }
    );
  }

  // Save admin user
  await admin.save();

  console.log("DB seeded with admin account, roles, and permissions");
}

seedDB().then(() => {
  mongoose.connection.close();
});
```

------------------------------------------------------------------------------------

File: server/src/routes/auth/index.js

Code for file:

```
import express from "express";
import {
  forgotPasswordRouteHandler,
  loginRouteHandler,
  registerRouteHandler,
  resetPasswordRouteHandler,
} from "../../services/auth/index.js";

const router = express.Router();

router.post("/login", async (req, res, next) => {
  console.log("Login route hit. Request body:", req.body);
  await loginRouteHandler(req, res);
});

router.post("/logout", (req, res) => {
  return res.sendStatus(204);
});

router.post("/register", async (req, res) => {
  await registerRouteHandler(req, res);
});

router.post("/password-forgot", async (req, res) => {
  await forgotPasswordRouteHandler(req, res);
});

router.post("/password-reset", async (req, res) => {
  await resetPasswordRouteHandler(req, res);
});

export default router;


```

------------------------------------------------------------------------------------

File: server/src/routes/categories/index.js

Code for file:

```
import express from "express";
import passport from "passport";
import {
  createCategoryRoute,
  deleteCategoryRoute,
  editCategoryRoute,
  getCategoriesRoute,
  getCategoryRoute,
} from "../../services/categories";
import jwt from "jsonwebtoken";
const router = express.Router();

// get all categories
router.get(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getCategoriesRoute(req, res);
  }
);

// create a category
router.post(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await createCategoryRoute(req, res);
  }
);

// get selected category
router.get(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getCategoryRoute(req, res);
  }
);

// edit selected category
router.patch(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await editCategoryRoute(req, res);
  }
);

// delete category
router.delete(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await deleteCategoryRoute(req, res);
  }
);

export default router;

```

------------------------------------------------------------------------------------

File: server/src/routes/images/index.js

Code for file:

```
import express from "express";
import passport from "passport";
import fs from "fs";
import path from "path";

const router = express.Router();

router.get("/users/:id/:name", (req, res) => {
  const id = req.params.id;
  const fileName = req.params.name;
  res.setHeader("Content-Type", "image/*");
  fs.createReadStream(
    path.resolve(process.cwd(), `./public/images/users/${id}/${fileName}`)
  ).pipe(res);
});

router.get("/items/:id/:name", (req, res) => {
  const id = req.params.id;
  const fileName = req.params.name;
  res.setHeader("Content-Type", "image/*");
  fs.createReadStream(
    path.resolve(process.cwd(), `./public/images/items/${id}/${fileName}`)
  ).pipe(res);
});

router.get("/:name", (req, res) => {
  const fileName = req.params.name;
  res.setHeader("Content-Type", "image/*");
  fs.createReadStream(
    path.resolve(process.cwd(), `./public/images/${fileName}`)
  ).pipe(res);
});

export default router;

```

------------------------------------------------------------------------------------

File: server/src/routes/items/index.js

Code for file:

```
import express from "express";
import passport from "passport";
import {
  getItemsRoute,
  getItemRoute,
  createItemRoute,
  editItemRoute,
  deleteItemRoute,
  getCategoryOfItemRoute,
  getTagsOfItemRoute,
} from "../../services/items";
import jwt from "jsonwebtoken";
const router = express.Router();

router.get(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getItemsRoute(req, res);
  }
);

router.post(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await createItemRoute(req, res);
  }
);

router.get(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getItemRoute(req, res);
  }
);

router.patch(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await editItemRoute(req, res);
  }
);

router.delete(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await deleteItemRoute(req, res);
  }
);

router.get(
  "/:id/category",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getCategoryOfItemRoute(req, res);
  }
);

router.get(
  "/:id/tags",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getTagsOfItemRoute(req, res);
  }
);

export default router;

```

------------------------------------------------------------------------------------

File: server/src/routes/me/index.js

Code for file:

```
import express from "express";
import passport from "passport";
import jwt from "jsonwebtoken";
import {
  getProfileRouteHandler,
  patchProfileRouteHandler,
} from "../../services/me";

const router = express.Router();

// get user's profile
router.get(
  "/",
  passport.authenticate("jwt", { session: false }),
  (req, res) => {
    getProfileRouteHandler(req, res);
  }
);

// update user's profile
router.patch(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    patchProfileRouteHandler(req, res);
  }
);

export default router;
```

------------------------------------------------------------------------------------

File: server/src/routes/permissions/index.js

Code for file:

```
import express from "express";
import passport from "passport";
import { getPermissionsRoute } from "../../services/permissions";
import jwt from "jsonwebtoken";
const router = express.Router();

// get user's profile
router.get(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getPermissionsRoute(req, res);
  }
);

export default router;
```

------------------------------------------------------------------------------------

File: server/src/routes/products/index.js

Code for file:

```
import express from "express";
import {
  getProducts,
  createProduct,
  updateProduct,
  deleteProduct,
} from "../../services/products/index.js";
import { protect, authorize } from "../../middleware/authMiddleware/index.js";

const router = express.Router();

router.get("/", getProducts);
router.post("/", protect, authorize("admin"), createProduct);
router.put("/:id", protect, authorize("admin"), updateProduct);
router.delete("/:id", protect, authorize("admin"), deleteProduct);

export default router;
```

------------------------------------------------------------------------------------

File: server/src/routes/roles/index.js

Code for file:

```
import express from "express";
import passport from "passport";
import {
  getRolesRoute,
  getRoleRoute,
  deleteRoleRoute,
  createRoleRoute,
  editRoleRoute,
} from "../../services/roles/index.js";
import jwt from "jsonwebtoken";
const router = express.Router();

// get all roles
router.get(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getRolesRoute(req, res);
  }
);

// create a role
router.post(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await createRoleRoute(req, res);
  }
);

// get user's role
router.get(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getRoleRoute(req, res);
  }
);

// edit a role
router.patch(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await editRoleRoute(req, res);
  }
);

// deelte role
router.delete(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await deleteRoleRoute(req, res);
  }
);

export default router;
```

------------------------------------------------------------------------------------

File: server/src/routes/settings/index.js

Code for file:

```
import express from "express";
import { getSettings, updateSettings } from "../../services/settings/index.js";
import { protect, authorize } from "../../middleware/authMiddleware/index.js";

const router = express.Router();

router.get("/", protect, getSettings);
router.put("/", protect, updateSettings);

export default router;
```

------------------------------------------------------------------------------------

File: server/src/routes/tags/index.js

Code for file:

```
import express from "express";
import passport from "passport";
import {
  createTagRoute,
  deleteTagRoute,
  editTagRoute,
  getTagRoute,
  getTagsRoute,
} from "../../services/tags";
import jwt from "jsonwebtoken";
const router = express.Router();

// get all roles
router.get(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getTagsRoute(req, res);
  }
);

// create a role
router.post(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await createTagRoute(req, res);
  }
);

// get user's role
router.get(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getTagRoute(req, res);
  }
);

// edit a role
router.patch(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await editTagRoute(req, res);
  }
);

// deelte role
router.delete(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await deleteTagRoute(req, res);
  }
);

export default router;
```

------------------------------------------------------------------------------------

File: server/src/routes/uploads/index.js

Code for file:

```
import express from "express";
import passport from "passport";
import multer from "multer";
import { fs } from "file-system";
import { v4 as uuidv4 } from "uuid";
import { setItemImage, setUserProfileImageRoute } from "../../services/uploads";
import jwt from "jsonwebtoken";
import path from "path";

const router = express.Router();
const randomId = uuidv4();

const storageUsers = multer.diskStorage({
  destination: function (req, file, cb) {
    const id = req.params.id;
    if (!fs.existsSync("./public/images/users/")) {
      fs.mkdirSync("./public/images/users/");
    }
    const path = `./public/images/users/${id}`;
    fs.mkdirSync(path, { recursive: true });
    return cb(null, path);
  },
  filename: function (req, file, cb) {
    cb(null, `${randomId}-${file.originalname}`);
  },
});

const storageItems = multer.diskStorage({
  destination: function (req, file, cb) {
    const id = req.params.id;
    if (!fs.existsSync("./public/images/items/")) {
      fs.mkdirSync("./public/images/items/");
    }
    const path = `./public/images/items/${id}`;
    fs.mkdirSync(path, { recursive: true });
    return cb(null, path);
  },
  filename: function (req, file, cb) {
    cb(null, `${randomId}-${file.originalname}`);
  },
});
const uploadStorageUsers = multer({ storage: storageUsers });
const uploadStoageItems = multer({ storage: storageItems });

router.post(
  "/users/:id/profile-image",
  uploadStorageUsers.single("attachment"),
  async (req, res) => {
    await setUserProfileImageRoute(randomId, req, res);
  }
);

router.post(
  "/items/:id/image",
  uploadStoageItems.single("attachment"),
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await setItemImage(randomId, req, res);
  }
);
export default router;
```

------------------------------------------------------------------------------------

File: server/src/routes/users/index.js

Code for file:

```
import express from "express";
import passport from "passport";
import {
  createUserRoute,
  deleteUserRoute,
  editUserRoute,
  getUserRoute,
  getUsersRoute,
} from "../../services/users/index.js";
import jwt from "jsonwebtoken";
const router = express.Router();

router.get(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getUsersRoute(req, res);
  }
);

router.post(
  "/",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await createUserRoute(req, res);
  }
);

router.get(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await getUserRoute(req, res);
  }
);

router.patch(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await editUserRoute(req, res);
  }
);

router.delete(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    await deleteUserRoute(req, res);
  }
);

export default router;
```

------------------------------------------------------------------------------------

File: server/src/routes/index.js

Code for file:

```
import express from "express";
import userRoutes from "./users/index.js";
import authRoutes from "./auth/index.js";
import roleRoutes from "./roles/index.js";
import settingsRoutes from "./settings/index.js";
import productRoutes from "./products/index.js";

const router = express.Router();

router.use("/auth", authRoutes);
router.use("/users", userRoutes);
router.use("/roles", roleRoutes);
router.use("/settings", settingsRoutes);
router.use("/products", productRoutes);

export default router;

```

------------------------------------------------------------------------------------

File: server/src/schemas/category.schema.js

Code for file:

```
import mongoose from "mongoose";

const categorySchema = new mongoose.Schema({
  name: { required: true, type: String },
  description: { required: true, type: String },
  items: [{ type: mongoose.Schema.Types.ObjectId, ref: "Item", default: [] }],
  created_at: { type: Date },
  updated_at: { type: Date },
});

categorySchema.virtual("id").get(function () {
  return this._id.toHexString();
});

categorySchema.set("toJSON", { virtuals: true });

export const categoryModel = mongoose.model("Category", categorySchema);
```

------------------------------------------------------------------------------------

File: server/src/schemas/item.schema.js

Code for file:

```
import mongoose from "mongoose";

const itemSchema = new mongoose.Schema({
  name: { required: true, type: String },
  excerpt: { required: true, type: String },
  description: { required: true, type: String },
  is_on_homepage: { type: Boolean, default: false },
  status: {
    type: String,
    enum: ["published", "archive", "draft"],
    default: "published",
  },
  date_at: { type: Date },
  created_at: { type: Date },
  updated_at: { type: Date },
  category_id: { type: mongoose.Schema.Types.ObjectID, ref: "Category" },
  tags: { type: [mongoose.Schema.Types.ObjectID], ref: "Tag", default: [] },
  image: { type: String },
});

export const itemModel = mongoose.model("Item", itemSchema);
```

------------------------------------------------------------------------------------

File: server/src/schemas/passwordResets.schema.js

Code for file:

```
import mongoose from "mongoose";

const passwordResetSchema = new mongoose.Schema({
  email: { required: true, type: String },
  token: { required: true, type: String },
  created_at: { type: Date },
});

passwordResetSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

passwordResetSchema.set("toJSON", { virtuals: true });

export const passwordResetModel = mongoose.model(
  "PasswordReset",
  passwordResetSchema
);
```

------------------------------------------------------------------------------------

File: server/src/schemas/permission.schema.js

Code for file:

```
import mongoose from "mongoose";

const permissionSchema = new mongoose.Schema({
  name: { required: true, type: String },
  created_at: { type: Date },
  updated_at: { type: Date },
});

permissionSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

permissionSchema.set("toJSON", { virtuals: true });

export const permissionModel = mongoose.model("Permission", permissionSchema);
```

------------------------------------------------------------------------------------

File: server/src/schemas/product.schema.js

Code for file:

```
import mongoose from "mongoose";

const productSchema = new mongoose.Schema({
  name: { type: String, required: true },
  description: { type: String, required: true },
  price: { type: Number, required: true },
  image: { type: String },
  category: { type: String },
  stock: { type: Number, default: 0 },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
});

export const productModel = mongoose.model("Product", productSchema);
```

------------------------------------------------------------------------------------

File: server/src/schemas/role.schema.js

Code for file:

```
import mongoose from "mongoose";

const roleSchema = new mongoose.Schema({
  name: { type: String, required: true, unique: true },
  permissions: [{ type: mongoose.Schema.Types.ObjectId, ref: "Permission" }],
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
});

export const roleModel = mongoose.model("Role", roleSchema);
```

------------------------------------------------------------------------------------

File: server/src/schemas/tag.schema.js

Code for file:

```
import mongoose from "mongoose";

const tagSchema = new mongoose.Schema({
  name: { required: true, type: String },
  color: { required: true, type: String },
  items: [{ type: mongoose.Schema.Types.ObjectId, ref: "Item", default: [] }],
  created_at: { type: Date },
  updated_at: { type: Date },
});

tagSchema.virtual("id").get(function () {
  return this._id.toHexString();
});

tagSchema.set("toJSON", { virtuals: true });

export const tagModel = mongoose.model("Tag", tagSchema);
```

------------------------------------------------------------------------------------

File: server/src/schemas/user.schema.js

Code for file:

```
import mongoose from "mongoose";
import bcrypt from "bcrypt";

const userSchema = new mongoose.Schema({
  name: { type: String, required: true },
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  role: {
    type: String,
    enum: ["admin", "prosperaTeam", "kol", "user"],
    default: "user",
  },
  arbitrumWallet: { type: String, required: true, unique: true },
  profileImage: { type: String },
  customSettings: {
    AugmentedReality: {
      calendar: { type: Object },
      todoList: [{ type: String }],
      emailIntegration: { type: Object },
      musicPlayer: { type: Object },
      weather: { type: Object },
    },
    dashboard: { type: Object },
    portfolio: { type: Object },
  },
  prosTokenBalance: { type: Number, default: 0 },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date },
});

userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

export const userModel = mongoose.model("User", userSchema);
```

------------------------------------------------------------------------------------

File: server/src/services/auth/index.js

Code for file:

```
import dotenv from "dotenv";
import nodemailer from "nodemailer";
import crypto from "crypto";
import bcrypt from "bcrypt";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { SignJWT, jwtVerify, importPKCS8, importSPKI } from "jose";
import { userModel } from "../../schemas/user.schema.js";
import { roleModel } from "../../schemas/role.schema.js";
import { passwordResetModel } from "../../schemas/passwordResets.schema.js";

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const privateKeyPath = path.join(
  __dirname,
  "..",
  "..",
  "..",
  "config",
  "keys",
  "ed25519-private.key"
);
const publicKeyPath = path.join(
  __dirname,
  "..",
  "..",
  "..",
  "config",
  "keys",
  "ed25519-public.key"
);

let privateKey, publicKey;

async function initializeKeys() {
  const privateKeyData = fs.readFileSync(privateKeyPath, "utf8");
  const publicKeyData = fs.readFileSync(publicKeyPath, "utf8");
  privateKey = await importPKCS8(privateKeyData, "EdDSA");
  publicKey = await importSPKI(publicKeyData, "EdDSA");
}

await initializeKeys();

const transporter = nodemailer.createTransport({
  host: process.env.MAILTRAP_HOST,
  port: process.env.MAILTRAP_PORT,
  auth: {
    user: process.env.MAILTRAP_USER,
    pass: process.env.MAILTRAP_PASS,
  },
});

function generateSecureToken(length = 32) {
  return crypto.randomBytes(length).toString("hex");
}

async function generateToken(payload) {
  const jwt = await new SignJWT(payload)
    .setProtectedHeader({ alg: "EdDSA" })
    .setIssuedAt()
    .setExpirationTime("24h")
    .sign(privateKey);
  return jwt;
}

export async function verifyToken(token) {
  try {
    const { payload } = await jwtVerify(token, publicKey, {
      algorithms: ["EdDSA"],
    });
    return payload;
  } catch (error) {
    console.error("Token verification failed:", error.message);
    return null;
  }
}

export const loginRouteHandler = async (req, res) => {
  console.log("Login handler. Request body:", req.body);
  const { emailOrUsername, password } = req.body.data.attributes;

  console.log("Attempting to find user with:", { emailOrUsername });

  let foundUser = await userModel.findOne({
    $or: [{ email: emailOrUsername }, { username: emailOrUsername }],
  });

  if (!foundUser) {
    console.log("User not found");
    return res.status(400).json({
      errors: [{ detail: "Invalid credentials" }],
    });
  }

  console.log("User found, checking password");

  const validPassword = await foundUser.matchPassword(password);
  if (!validPassword) {
    console.log("Invalid password");
    return res.status(400).json({
      errors: [{ detail: "Invalid credentials" }],
    });
  }

  console.log("Password valid, generating token");

  const token = await generateToken({
    id: foundUser.id,
    email: foundUser.email,
    role: foundUser.role,
  });

  res.cookie("token", token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    domain: ".prosperadefi.com",
    maxAge: 24 * 60 * 60 * 1000, // 1 day
  });

  return res.json({
    message: "Logged in successfully",
    user: {
      id: foundUser.id,
      name: foundUser.name,
      email: foundUser.email,
      username: foundUser.username,
      role: foundUser.role,
      arbitrumWallet: foundUser.arbitrumWallet,
    },
  });
};

export const logoutRouteHandler = (req, res) => {
  res.clearCookie("token", {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    domain: ".prosperadefi.com",
  });

  res.json({ message: "Logged out successfully" });
};

export const registerRouteHandler = async (req, res) => {
  const { name, email, password, arbitrumWallet } = req.body.data.attributes;

  let foundUser = await userModel.findOne({ email: email });
  if (foundUser) {
    return res.status(400).json({ message: "The email is already in use" });
  }

  foundUser = await userModel.findOne({ arbitrumWallet: arbitrumWallet });
  if (foundUser) {
    return res
      .status(400)
      .json({ message: "The Arbitrum wallet is already in use" });
  }

  if (!password || password.length < 8) {
    return res
      .status(400)
      .json({ message: "The password must be at least 8 characters long." });
  }

  const salt = await bcrypt.genSalt(10);
  const hashPassword = await bcrypt.hash(password, salt);

  let userRole = await roleModel.findOne({ name: "user" });

  const newUser = new userModel({
    name: name,
    email: email,
    password: hashPassword,
    arbitrumWallet: arbitrumWallet,
    role: userRole._id,
  });
  await newUser.save();

  const token = await generateToken({
    id: newUser.id,
    email: newUser.email,
    role: newUser.role,
  });

  res.cookie("token", token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    domain: ".prosperadefi.com",
    maxAge: 24 * 60 * 60 * 1000, // 1 day
  });

  return res.status(200).json({
    message: "Registered successfully",
    user: {
      id: newUser.id,
      name: newUser.name,
      email: newUser.email,
      role: newUser.role,
      arbitrumWallet: newUser.arbitrumWallet,
    },
    token: token,
  });
};

export const forgotPasswordRouteHandler = async (req, res) => {
  const { email } = req.body;
  let foundUser = await userModel.findOne({ email: email });

  if (!foundUser) {
    return res.status(400).json({
      errors: { email: ["The email does not match any existing user."] },
    });
  }

  let token = generateSecureToken();
  let info = await transporter.sendMail({
    from: '"PROSPERA DeFi" <noreply@prosperadefi.com>',
    to: email,
    subject: "Reset Password",
    html: `<p>You requested to change your password. If this request was not made by you, please contact us. Access <a href='${process.env.FRONTEND_URL}/auth/reset-password?token=${token}&email=${email}'>this link</a> to reset your password </p>`,
  });

  await passwordResetModel.create({
    email: foundUser.email,
    token: token,
    created_at: new Date(),
  });

  return res.status(200).json({ message: "Password reset email sent" });
};

export const resetPasswordRouteHandler = async (req, res) => {
  const { email, token, password, password_confirmation } = req.body;

  const foundUser = await userModel.findOne({ email: email });
  const foundToken = await passwordResetModel.findOne({
    email: email,
    token: token,
  });

  if (!foundUser || !foundToken) {
    return res
      .status(400)
      .json({ errors: { email: ["The email or token is invalid."] } });
  }

  if (password.length < 8) {
    return res.status(400).json({
      errors: {
        password: ["The password should have at least 8 characters."],
      },
    });
  }

  if (password !== password_confirmation) {
    return res.status(400).json({
      errors: {
        password: ["The password and password confirmation must match."],
      },
    });
  }

  const salt = await bcrypt.genSalt(10);
  const hashPassword = await bcrypt.hash(password, salt);

  await passwordResetModel.deleteOne({ email: foundUser.email });

  await userModel.updateOne(
    { email: foundUser.email },
    { $set: { password: hashPassword } }
  );

  return res.status(200).json({ message: "Password reset successfully" });
};

export const verifyAuth = async (req, res, next) => {
  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ message: "Authentication required" });
  }

  const payload = await verifyToken(token);
  if (!payload) {
    return res.status(401).json({ message: "Invalid or expired token" });
  }

  req.user = payload;
  next();
};
```

------------------------------------------------------------------------------------

File: server/src/services/categories/index.js

Code for file:

```
import { categoryModel } from "../../schemas/category.schema";

export const getCategoriesRoute = async (req, res) => {
  let categoriesObjectArray = [];
  let jsonArrayCategories = {};

  // pagination
  let paginationSize = null;
  let pageNumber = null;
  if (req.query.page) {
    if (req.query.page.number) {
      pageNumber = +req.query.page.number;
    }
    if (req.query.page.size) {
      paginationSize = +req.query.page.size;
    }
  }

  // filtering
  let filters = {};
  if (req.query.filter) {
    filters = req.query.filter;
  }

  // sorting
  let sortValue;
  if (req.query.sort) {
    sortValue = req.query.sort;
  }

  // choose fields
  let fieldsCategory;
  if (req.query.fields) {
    if (req.query.fields.categories) {
      fieldsCategory = req.query.fields.categories.split(",");
    }
  }

  const allCategories = await categoryModel
    .find(filters)
    .select(fieldsCategory)
    .limit(paginationSize)
    .skip((pageNumber - 1) * paginationSize)
    .sort(sortValue);

  categoriesObjectArray = allCategories.map((element) => {
    let jsonObj = {
      type: "categories",
      id: element.id,
      attributes: {
        ...element._doc,
      },
    };
    return (jsonArrayCategories = { ...jsonArrayCategories, ...jsonObj });
  });

  const sentData = { data: [...categoriesObjectArray] };
  return res.status(200).send(sentData);
};

export const getCategoryRoute = async (req, res) => {
  const categoryId = req.params.id;

  let fieldsCategory;
  if (req.query.fields) {
    if (req.query.fields.categories) {
      fieldsCategory = req.query.fields.categories.split(",");
    }
  }

  const foundCategory = await categoryModel
    .findOne({ _id: categoryId })
    .select(fieldsCategory);
  if (!foundCategory) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The category can not be found" }] });
  }

  const sentData = {
    data: {
      type: "categories",
      id: foundCategory.id,
      attributes: {
        ...foundCategory._doc,
      },
    },
  };
  return res.status(200).send(sentData);
};

export const createCategoryRoute = async (req, res) => {
  const { name, description } = req.body.data.attributes;

  if (!name) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The name is required" }] });
  }
  if (!description) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The description is required" }] });
  }

  const existingCategory = await categoryModel.findOne({ name: name });
  if (existingCategory) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The category already exists" }] });
  }
  const newCategory = new categoryModel({
    name: name,
    description: description,
    created_at: Date.now(),
    updated_at: Date.now(),
  });
  newCategory.save();
  const sentData = {
    data: {
      type: "categories",
      id: newCategory.id,
      attributes: {
        ...newCategory._doc,
      },
    },
  };
  return res.status(201).send(sentData);
};

export const editCategoryRoute = async (req, res) => {
  const categoryId = req.params.id;
  const { name, description } = req.body.data.attributes;

  if (!name) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The name is required" }] });
  }
  if (!description) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The description is required" }] });
  }

  const foundCategory = await categoryModel.findById(categoryId);
  if (!foundCategory) {
    return res
      .status(400)
      .json({ errors: [{ detail: "No category was found" }] });
  }
  const existingCategoriesWithName = await categoryModel.find({
    name: name,
    _id: { $ne: categoryId },
  });
  if (existingCategoriesWithName.length > 0) {
    return res.status(400).send({
      errors: [{ detail: "Already exists a category with this name" }],
    });
  }
  const updatedCategory = await categoryModel.updateOne(
    { _id: categoryId },
    {
      name: name,
      description: description,
      created_at: Date.now(),
      updated_at: Date.now(),
    }
  );

  const sentData = {
    data: {
      type: "categories",
      id: categoryId,
      attributes: {
        ...updatedCategory._doc,
      },
    },
  };
  return res.status(200).send(sentData);
};

export const deleteCategoryRoute = async (req, res) => {
  const toDeleteCategory = await categoryModel.findById(req.params.id);

  if (!toDeleteCategory) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The category does not exist" }] });
  }

  if (toDeleteCategory.items.length > 0) {
    return res.status(400).send({
      errors: [
        {
          title:
            "The category can not be deleted because it is attached to items",
        },
      ],
    });
  }

  try {
    await categoryModel.deleteOne({ _id: toDeleteCategory._id });
    res.sendStatus(204);
  } catch (err) {
    console.error(err);
  }
};
```

------------------------------------------------------------------------------------

File: server/src/services/chat/index.js

Code for file:

```
import { Server } from "socket.io";

export const initializeChat = (server) => {
  const io = new Server(server, {
    cors: {
      origin: [process.env.FRONTEND_URL, process.env.DASHBOARD_URL],
      methods: ["GET", "POST"],
    },
  });

  io.on("connection", (socket) => {
    console.log("A user connected");

    socket.on("sendMessage", (message) => {
      io.emit("message", message);
    });

    socket.on("disconnect", () => {
      console.log("User disconnected");
    });
  });
};
```

------------------------------------------------------------------------------------

File: server/src/services/items/index.js

Code for file:

```
import dotenv from "dotenv";
import { itemModel } from "../../schemas/item.schema";
import { categoryModel } from "../../schemas/category.schema";
import { tagModel } from "../../schemas/tag.schema";

dotenv.config();

export const getItemsRoute = async (req, res) => {
  let itemsObjectArray = [];
  let jsonArrayItems = {};
  let options = [];

  if (req.query.include) {
    options = req.query.include.split(",");
  }

  // pagination
  let paginationSize = null;
  let pageNumber = null;
  if (req.query.page) {
    if (req.query.page.number) {
      pageNumber = +req.query.page.number;
    }
    if (req.query.page.size) {
      paginationSize = +req.query.page.size;
    }
  }

  // filtering
  let filters = {};
  if (req.query.filter) {
    filters = req.query.filter;
  }

  let sortValue;
  //sorting
  if (req.query.sort) {
    sortValue = req.query.sort;
  }

  // choose fields
  let fieldsItem;
  let fieldsTag;
  let fieldsCat;
  if (req.query.fields) {
    if (req.query.fields.item) {
      fieldsItem = req.query.fields.item.split(",");
    }
    if (req.query.fields.tags) {
      fieldsTag = req.query.fields.tags.split(",");
    }
    if (req.query.fields.category) {
      fieldsCat = req.query.fields.category.split(",");
    }
  }

  const allItems = await itemModel
    .find(filters)
    .select(fieldsItem)
    .limit(paginationSize)
    .skip((pageNumber - 1) * paginationSize)
    .sort(sortValue);

  itemsObjectArray = allItems.map((element) => {
    let jsonObj = {
      type: "items",
      id: element.id,
      attributes: {
        ...element._doc,
      },
      relationships: {
        category: {
          links: {
            self: `${process.env.APP_URL_API}/items/${element.id}/relationships/category`,
            related: `${process.env.APP_URL_API}/items/${element.id}/category`,
          },
        },
        tags: {
          links: {
            self: `${process.env.APP_URL_API}/items/${element.id}/relationships/tags`,
            related: `${process.env.APP_URL_API}/items/${element.id}/tags`,
          },
        },
      },
    };
    return (jsonArrayItems = { ...jsonArrayItems, ...jsonObj });
  });

  let tagsObjectArray = [];
  let categoriesObjectArray = [];
  if (options.length > 0) {
    if (options.find((el) => el == "tags")) {
      const allTags = await tagModel.find().select(fieldsTag);
      let jsonArrayTags = {};
      tagsObjectArray = allTags.map((element) => {
        let jsonObj = {
          type: "tags",
          id: element.id,
          attributes: {
            ...element._doc,
          },
        };
        return (jsonArrayTags = { ...jsonArrayTags, ...jsonObj });
      });
    }
    if (options.find((el) => el == "category")) {
      const allCategories = await categoryModel.find().select(fieldsCat);
      let jsonArrayCategories = {};
      categoriesObjectArray = allCategories.map((element) => {
        let jsonObj = {
          type: "categories",
          id: element.id,
          attributes: {
            ...element._doc,
          },
        };
        return (jsonArrayCategories = { ...jsonArrayCategories, ...jsonObj });
      });
    }
  }

  const sentData = {
    data: [...itemsObjectArray],
    included: [...categoriesObjectArray, ...tagsObjectArray],
  };
  return res.status(200).send(sentData);
};

export const getCategoryOfItemRoute = async (req, res) => {
  const item = await itemModel.findById(req.params.id);
  const categoryOfItem = await categoryModel.findOne({ _id: item.category_id });

  const sentData = {
    data: {
      type: "categories",
      id: categoryOfItem.id,
      attributes: {
        ...categoryOfItem._doc,
      },
    },
  };

  return res.status(200).send(sentData);
};

export const getTagsOfItemRoute = async (req, res) => {
  const item = await itemModel
    .findById(req.params.id)
    .populate("tags")
    .select("tags");
  const tagsOfItem = item.tags;

  let tagsObjectArray = [];
  let jsonArrayTags = {};

  tagsObjectArray = tagsOfItem.map((element) => {
    let jsonObj = {
      type: "tags",
      id: element.id,
      attributes: {
        ...element._doc,
      },
    };
    return (jsonArrayTags = { ...jsonArrayTags, ...jsonObj });
  });

  const sentData = { data: [...tagsObjectArray] };
  return res.status(200).send(sentData);
};

export const getItemRoute = async (req, res) => {
  // it can have included in the url category and tags
  let includedDataCategory;
  let includedDataTags = [];
  let options = [];

  const itemId = req.params.id;
  if (req.query.include) {
    options = req.query.include.split(",");
  }

  const item = await itemModel.findById(itemId);
  const categoryOfItem = await categoryModel.findById(item.category_id);
  const tagsOfItem = await tagModel.find({ _id: { $in: item["tags"] } });
  let sentData = {
    type: "items",
    id: itemId,
    attributes: {
      ...item._doc,
    },
  };

  if (options.length > 0) {
    if (options.find((el) => el == "category")) {
      sentData = {
        ...sentData,
        relationships: {
          category: {
            data: [
              {
                type: "categories",
                id: categoryOfItem.id,
              },
            ],
          },
        },
      };
      includedDataCategory = {
        type: "categories",
        id: categoryOfItem.id,
        attributes: {
          ...categoryOfItem._doc,
        },
      };
    }
    if (options.find((el) => el == "tags")) {
      let jsonArray = {};
      includedDataTags = tagsOfItem.map((element) => {
        let jsonObj = {
          type: "tags",
          id: element.id,
          attributes: {
            ...element._doc,
          },
        };
        return (jsonArray = { ...jsonArray, ...jsonObj });
      });
    }
  }
  const finalData = {
    data: { ...sentData },
    included: [{ ...includedDataCategory }, ...includedDataTags],
  };
  return res.status(200).send(finalData);
};

export const createItemRoute = async (req, res) => {
  const { name, excerpt, description, status, is_on_homepage, date_at, image } =
    req.body.data.attributes;
  const categoryId = req.body.data.relationships.category.data.id;
  const tags = req.body.data.relationships.tags.data;

  if (!name) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The name is required" }] });
  }
  if (!description) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The description is required" }] });
  }

  const existingItem = await itemModel.findOne({ name: name });
  if (existingItem) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The item already exists" }] });
  }

  const newItem = new itemModel({
    name: name,
    excerpt: excerpt,
    description: description,
    status: status,
    is_on_homepage: is_on_homepage,
    date_at: date_at,
    image: image,
    category_id: categoryId,
    created_at: Date.now(),
    updated_at: Date.now(),
  });

  tags.map((tag) => newItem.tags.push(tag.id));
  await newItem.save();
  // add for category the item
  const category = await categoryModel.findById(categoryId);
  await categoryModel.updateOne(
    { _id: categoryId },
    { items: [...category.items, newItem._id] }
  );

  // add for tags the item
  await Promise.all(
    tags.map(async (element) => {
      const result = await tagModel.findById(element.id);
      await tagModel.updateOne(
        { _id: element.id },
        { items: [...result.items, newItem._id] }
      );
    })
  );

  const sentData = {
    data: {
      type: "items",
      id: newItem.id,
      attributes: {
        ...newItem._doc,
      },
      relationships: {
        category: {
          links: {
            self: `${process.env.APP_URL_API}/items/${newItem.id}/relationships/category`,
            related: `${process.env.APP_URL_API}/items/${newItem.id}/category`,
          },
        },
        tags: {
          links: {
            self: `${process.env.APP_URL_API}/items/${newItem.id}/relationships/tags`,
            related: `${process.env.APP_URL_API}/items/${newItem.id}/tags`,
          },
        },
      },
    },
  };
  return res.status(201).send(sentData);
};

export const editItemRoute = async (req, res) => {
  const foundItem = await itemModel.findById(req.params.id);
  const itemId = req.params.id;
  const { name, excerpt, description, status, is_on_homepage, date_at, image } =
    req.body.data.attributes;

  let categoryId;
  let tags;
  let oldCategory = await categoryModel.findById(foundItem.category_id);
  let oldTags = await tagModel.find({ _id: { $in: foundItem["tags"] } });
  if (req.body.data.relationships) {
    categoryId = req.body.data.relationships.category.data.id;
    tags = req.body.data.relationships.tags.data;
  } else {
    categoryId = foundItem.category_id;
    tags = await tagModel.find({ _id: { $in: foundItem["tags"] } });
  }

  if (!foundItem) {
    return res
      .status(400)
      .json({ errors: [{ detail: "The item does not exist" }] });
  }

  if (name) {
    const existingItemsWithName = await itemModel.find({
      name: name,
      _id: { $ne: itemId },
    });
    if (existingItemsWithName.length > 0) {
      return res.status(400).send({
        errors: [{ detail: "Already exists an item with this name" }],
      });
    }
  }

  const toSentTags = tags.map((tag) => tag.id);

  const updatedItem = await itemModel.updateOne(
    { _id: foundItem._id },
    {
      name: name,
      excerpt: excerpt,
      description: description,
      status: status,
      is_on_homepage: is_on_homepage,
      date_at: date_at,
      image: image,
      tags: [...toSentTags],
      category_id: categoryId,
      updated_at: Date.now(),
    }
  );

  // check category changed
  if (oldCategory._id != categoryId) {
    const results = oldCategory.items.filter(
      (value) => !value.equals(foundItem._id)
    );
    await categoryModel.updateOne(
      { _id: oldCategory._id },
      { items: [...results] }
    );
    const newCategory = await categoryModel.findById(categoryId);
    await categoryModel.updateOne(
      { _id: categoryId },
      { items: [...newCategory.items, foundItem._id] }
    );
  }
  //change tags
  await Promise.all(
    oldTags.map(async (tag) => {
      const results = tag.items.filter((value) => !value.equals(foundItem._id));
      await tagModel.updateOne({ _id: tag._id }, { items: [...results] });
    })
  );

  await Promise.all(
    tags.map(async (tag) => {
      const elem = await tagModel.findById(tag.id);
      await tagModel.updateOne(
        { _id: tag.id },
        { items: [...elem.items, foundItem._id] }
      );
    })
  );

  const sentData = {
    data: "items",
    id: foundItem.id,
    attributes: {
      ...updatedItem._doc,
    },
  };
  return res.status(200).send(sentData);
};

export const deleteItemRoute = async (req, res) => {
  // here should be verification if demo and other stuff?
  const toDeleteItem = await itemModel.findById(req.params.id);
  if (!toDeleteItem) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The item does not exist" }] });
  } else {
    try {
      // remove from tag the item
      const tags = await tagModel.find({ _id: { $in: toDeleteItem["tags"] } });
      await Promise.all(
        tags.map(async (tag) => {
          const results = tag.items.filter(
            (value) => !value.equals(toDeleteItem._id)
          );
          await tagModel.updateOne({ _id: tag._id }, { items: [...results] });
        })
      );

      // remove from categories the tag
      const category = await categoryModel.findById(toDeleteItem.category_id);
      const results = category.items.filter(
        (value) => !value.equals(toDeleteItem._id)
      );
      await categoryModel.updateOne(
        { _id: category._id },
        { items: [...results] }
      );

      await itemModel.deleteOne({ _id: toDeleteItem._id });
      res.sendStatus(204);
    } catch (err) {
      console.error(err);
    }
  }
};
```

------------------------------------------------------------------------------------

File: server/src/services/me/index.js

Code for file:

```
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import { roleModel } from "../../schemas/role.schema";
import { permissionModel } from "../../schemas/permission.schema";
import { userModel } from "../../schemas/user.schema";

export const getProfileRouteHandler = async (req, res) => {
  let fieldsUsers = [];
  let fieldsRoles = [];
  let fieldsPerms = [];
  if (req.query.fields) {
    if (req.query.fields.users) {
      fieldsUsers = req.query.fields.users.split(",");
    }
    if (req.query.fields.roles) {
      fieldsRoles = req.query.fields.roles.split(",");
    }
    if (req.query.fields.permissions) {
      fieldsPerms = req.query.fields.permissions.split(",");
    }
  }

  const meUser = await userModel
    .findOne({ _id: req.user._id })
    .select(fieldsUsers);
  const role = await roleModel
    .findOne({ _id: req.user.role })
    .select(fieldsRoles);
  let permissions = await permissionModel
    .find({ _id: { $in: role["permissions"] } })
    .select(fieldsPerms);

  let options = [];
  let includedDataPermissions = [];
  if (req.query.include) {
    options = req.query.include.split(",");
  }

  // included options
  let objectRoles = {};
  if (options.length > 0) {
    if (options.find((el) => el == "roles")) {
      objectRoles = {
        type: "roles",
        id: role.id,
        attributes: {
          ...role._doc,
        },
      };
    }

    if (options.find((el) => el == "roles.permissions")) {
      let jsonArray = {};
      includedDataPermissions = permissions.map((element) => {
        let jsonObj = {
          type: "permissions",
          id: element.id,
          attributes: {
            ...element._doc,
          },
        };
        return (jsonArray = { ...jsonArray, ...jsonObj });
      });
    }
  }

  const sentData = {
    data: {
      type: "users",
      id: meUser.id,
      attributes: meUser,
    },
    included: [objectRoles, ...includedDataPermissions],
  };
  delete sentData.data.attributes.password;
  res.send(sentData);
};

export const patchProfileRouteHandler = async (req, res) => {
  const currentDataOfUser = req.user;
  const { name, email } = req.body.data.attributes;
  const newPassword = req.body.data.attributes.password_new;
  const confirmPassword = req.body.data.attributes.password_confirmation;
  const foundUser = await userModel.findOne({ email: currentDataOfUser.email });

  if (!foundUser) {
    res.status(400).json({ error: "No user matches the credentials" });
  } else {
    // check password more than 8 characters, new password matched the password confirmation
    if ((newPassword && newPassword < 7) || newPassword != confirmPassword) {
      res.status(400).json({
        errors: {
          password: [
            "The password should have at lest 8 characters and match the password confirmation.",
          ],
        },
      });
    } else if (
      newPassword &&
      newPassword > 7 &&
      newPassword == confirmPassword
    ) {
      const salt = await bcrypt.genSalt(10);
      const hashPassword = await bcrypt.hash(newPassword, salt);
      try {
        const response = await userModel.updateOne(
          { email: foundUser.email },
          { $set: { name: name, email: email, password: hashPassword } }
        );
      } catch (err) {
        console.error(err);
      }
      const sentData = {
        data: {
          type: "users",
          id: foundUser.id,
          attributes: {
            name: name,
            email: email,
            profile_image: foundUser.profile_image,
          },
        },
      };
      res.send(sentData);
    } else if (!newPassword) {
      try {
        await userModel.updateOne(
          { email: foundUser.email },
          { $set: { name: name, email: email } }
        );
      } catch (err) {
        console.error(err);
      }
      const sentData = {
        data: {
          type: "users",
          id: foundUser.id,
          attributes: {
            name: name,
            email: email,
            profile_image: foundUser.profile_image,
          },
        },
      };
      res.send(sentData);
    }
  }
};
```

------------------------------------------------------------------------------------

File: server/src/services/permissions/index.js

Code for file:

```
import { permissionModel } from "../../schemas/permission.schema";

export const getPermissionsRoute = async (req, res) => {
  let permissionsObjectArray = [];
  let jsonArrayPermissions = {};

  // pagination
  let paginationSize = null;
  let pageNumber = null;
  if (req.query.page) {
    if (req.query.page.number) {
      pageNumber = +req.query.page.number;
    }
    if (req.query.page.size) {
      paginationSize = +req.query.page.size;
    }
  }

  // choose fields
  let fieldsPerms;
  if (req.query.fields) {
    if (req.query.fields.permissions) {
      fieldsPerms = req.query.fields.permissions.split(",");
    }
  }

  const allPermissions = await permissionModel
    .find()
    .select(fieldsPerms)
    .limit(paginationSize)
    .skip((pageNumber - 1) * paginationSize);

  permissionsObjectArray = allPermissions.map((element) => {
    let jsonObj = {
      type: "permissions",
      id: element.id,
      attributes: {
        ...element._doc,
      },
    };
    return (jsonArrayPermissions = { ...jsonArrayPermissions, ...jsonObj });
  });

  const sentData = { data: [...permissionsObjectArray] };
  return res.status(200).send(sentData);
};
```

------------------------------------------------------------------------------------

File: server/src/services/products/index.js

Code for file:

```
import { productModel } from "../../schemas/product.schema.js";

export const getProducts = async (req, res) => {
  try {
    const products = await productModel.find();
    res.json(products);
  } catch (error) {
    res.status(500).json({ message: "Error fetching products" });
  }
};

export const createProduct = async (req, res) => {
  try {
    const product = new productModel(req.body);
    await product.save();
    res.status(201).json(product);
  } catch (error) {
    res.status(500).json({ message: "Error creating product" });
  }
};

export const updateProduct = async (req, res) => {
  try {
    const product = await productModel.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    res.json(product);
  } catch (error) {
    res.status(500).json({ message: "Error updating product" });
  }
};

export const deleteProduct = async (req, res) => {
  try {
    await productModel.findByIdAndDelete(req.params.id);
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ message: "Error deleting product" });
  }
};
```

------------------------------------------------------------------------------------

File: server/src/services/roles/index.js

Code for file:

```
import dotenv from "dotenv";
import { roleModel } from "../../schemas/role.schema.js";
import { permissionModel } from "../../schemas/permission.schema.js";

dotenv.config();

export const createRoleForUser = async (obj) => {
  return await models.ModelHasRole.create(obj);
};

export const findRoleOfUser = async (whereClause) => {
  return await models.ModelHasRole(whereClause);
};

export const getRolesRoute = async (req, res) => {
  let rolesObjectArray = [];
  let jsonArrayRoles = {};

  // include
  let options = [];
  if (req.query.include) {
    options = req.query.include.split(",");
  }

  // pagination
  let paginationSize = null;
  let pageNumber = null;
  if (req.query.page) {
    if (req.query.page.number) {
      pageNumber = +req.query.page.number;
    }
    if (req.query.page.size) {
      paginationSize = +req.query.page.size;
    }
  }

  // filtering
  let filters = {};
  if (req.query.filter) {
    filters = req.query.filter;
  }

  // sorting
  let sortValue;
  if (req.query.sort) {
    sortValue = req.query.sort;
  }

  // choose fields
  let fieldsRoles;
  let fieldsPerms;
  let relObj;
  if (req.query.fields) {
    if (req.query.fields.roles) {
      fieldsRoles = req.query.fields.roles.split(",");
    }
    if (req.query.fields.permissions) {
      fieldsPerms = req.query.fields.permissions.split(",");
    }
  }

  const allRoles = await roleModel
    .find(filters)
    .select(fieldsRoles)
    .limit(paginationSize)
    .skip((pageNumber - 1) * paginationSize)
    .sort(sortValue);

  rolesObjectArray = allRoles.map((element) => {
    let jsonObj;
    jsonObj = {
      type: "roles",
      id: element.id,
      attributes: {
        ...element._doc,
      },
    };
    return (jsonArrayRoles = { ...jsonArrayRoles, ...jsonObj });
  });

  let includedDataPermissions = [];
  if (options.length > 0) {
    if (options.find((el) => el == "permissions")) {
      let permissions = await permissionModel.find().select(fieldsPerms);
      let jsonArray = {};
      includedDataPermissions = permissions.map((element) => {
        let jsonObj = {
          type: "permissions",
          id: element.id,
          attributes: {
            ...element._doc,
          },
        };
        return (jsonArray = { ...jsonArray, ...jsonObj });
      });
    }
  }

  let sentData = {
    data: [...rolesObjectArray],
    included: [...includedDataPermissions],
  };
  return res.send(sentData);
};

export const getRoleRoute = async (req, res) => {
  let options = [];
  if (req.query.include) {
    options = req.query.include;
  }

  let fieldsRoles;
  let fieldsPerms;
  if (req.query.fields) {
    if (req.query.fields.roles) {
      fieldsRoles = req.query.fields.roles.split(",");
    }
    if (req.query.fields.permissions) {
      fieldsPerms = req.query.fields.permissions.split(",");
    }
  }

  const role = await roleModel
    .findById(req.params.id)
    .populate("permissions")
    .select(fieldsRoles);

  let sentData = {
    type: "roles",
    id: role.id,
    attributes: {
      ...role._doc,
    },
  };

  let permObjectArray = [];
  if (options.length > 0) {
    const permissions = await permissionModel
      .find({ _id: { $in: role["permissions"] } })
      .select(fieldsPerms);
    let jsonArrayPermissions = {};
    permObjectArray = permissions.map((element) => {
      let jsonObj = {
        type: "permissions",
        id: element.id,
        attributes: {
          ...element._doc,
        },
      };
      return (jsonArrayPermissions = { ...jsonArrayPermissions, ...jsonObj });
    });
  }
  const finalData = { data: { ...sentData }, included: [...permObjectArray] };
  return res.status(200).send(finalData);
};

export const createRoleRoute = async (req, res) => {
  const { name } = req.body.data.attributes;
  if (!name) {
    return res.status(400).json({ errors: [{ detail: "Name is required" }] });
  }

  const existingRole = await roleModel.findOne({ name: name });
  if (existingRole) {
    return res
      .status(400)
      .json({ errors: [{ detail: "The name is already taken" }] });
  } else {
    const newRole = new roleModel({
      name: name,
      created_at: Date.now(),
      updated_at: Date.now(),
    });
    await newRole.save();
    const sentData = {
      data: "roles",
      id: newRole.id,
      attributes: {
        ...newRole._doc,
      },
    };
    return res.status(201).send(sentData);
  }
};

export const editRoleRoute = async (req, res) => {
  const { name } = req.body.data.attributes;
  const roleId = req.params.id;

  if (!name) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The name is required" }] });
  }

  const foundRole = await roleModel.findById(roleId);
  if (!foundRole) {
    return res.status(400).json({ errors: [{ detail: "No role was found" }] });
  }
  const existingRolesWithName = await roleModel.find({
    name: name,
    _id: { $ne: roleId },
  });
  if (existingRolesWithName.length > 0) {
    return res
      .status(400)
      .send({ errors: [{ detail: "Already exists a role with this name" }] });
  }
  const updatedRole = await roleModel.updateOne(
    { _id: roleId },
    { name: name, created_at: Date.now(), updated_at: Date.now() }
  );
  const sentData = {
    data: {
      type: "roles",
      id: roleId,
      attributes: {
        ...updatedRole._doc,
      },
    },
  };
  return res.status(200).send(sentData);
};

export const deleteRoleRoute = async (req, res) => {
  // can delete it if it is not linked to a user
  const toDeleteRole = await roleModel.findById(req.params.id);

  if (toDeleteRole.users.length > 0) {
    return res.status(400).json({
      errors: [{ title: "The role has users attached and can not be deleted" }],
    });
  } else {
    try {
      await roleModel.deleteOne({ _id: toDeleteRole._id });
      res.sendStatus(204);
    } catch (err) {
      console.error(err);
    }
  }
};

```

------------------------------------------------------------------------------------

File: server/src/services/settings/index.js

Code for file:

```
import { userModel } from "../../schemas/user.schema.js";

export const getSettings = async (userId) => {
  try {
    const user = await userModel.findById(userId);
    return user.customSettings;
  } catch (error) {
    throw new Error("Error fetching settings");
  }
};

export const updateSettings = async (userId, newSettings) => {
  try {
    const { AugmentedReality, dashboard, portfolio } = newSettings;
    const user = await userModel.findByIdAndUpdate(
      userId,
      {
        $set: {
          "customSettings.AugmentedReality": AugmentedReality,
          "customSettings.dashboard": dashboard,
          "customSettings.portfolio": portfolio,
        },
      },
      { new: true }
    );
    return user.customSettings;
  } catch (error) {
    throw new Error("Error updating settings");
  }
};

export const updateSpecificSettings = async (
  userId,
  settingsType,
  newSettings
) => {
  try {
    const updateQuery = {};
    updateQuery[`customSettings.${settingsType}`] = newSettings;

    const user = await userModel.findByIdAndUpdate(
      userId,
      { $set: updateQuery },
      { new: true }
    );
    return user.customSettings[settingsType];
  } catch (error) {
    throw new Error(`Error updating ${settingsType} settings`);
  }
};
```

------------------------------------------------------------------------------------

File: server/src/services/tags/index.js

Code for file:

```
import { tagModel } from "../../schemas/tag.schema";

export const getTagsRoute = async (req, res) => {
  let tagsObjectArray = [];
  let jsonArrayTags = {};

  let paginationSize = null;
  let pageNumber = null;
  let sortValue;
  let fieldsTag;
  let filters = {};

  if (req.query.page) {
    if (req.query.page.number) {
      pageNumber = +req.query.page.number;
    }
    if (req.query.page.size) {
      paginationSize = +req.query.page.size;
    }
  }
  if (req.query.sort) {
    sortValue = req.query.sort;
  }
  if (req.query.fields) {
    if (req.query.fields.tags) {
      fieldsTag = req.query.fields.tags.split(",");
    }
  }
  if (req.query.filter) {
    filters = req.query.filter;
  }

  const allTags = await tagModel
    .find(filters)
    .select(fieldsTag)
    .limit(paginationSize)
    .skip((pageNumber - 1) * paginationSize)
    .sort(sortValue);

  tagsObjectArray = allTags.map((element) => {
    let jsonObj = {
      type: "tags",
      id: element.id,
      attributes: {
        ...element._doc,
      },
    };
    return (jsonArrayTags = { ...jsonArrayTags, ...jsonObj });
  });

  const sentData = {
    data: [...tagsObjectArray],
  };
  return res.status(200).send(sentData);
};

export const getTagRoute = async (req, res) => {
  const tagId = req.params.id;
  let fieldsTag;
  if (req.query.fields) {
    if (req.query.fields.tags) {
      fieldsTag = req.query.fields.tags.split(",");
    }
  }

  const foundTag = await tagModel.findById(tagId).select(fieldsTag);
  if (!foundTag) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The tag was not found" }] });
  }

  const sentData = {
    data: {
      type: "tags",
      id: foundTag.id,
      attributes: {
        ...foundTag._doc,
      },
    },
  };
  return res.status(200).send(sentData);
};

export const createTagRoute = async (req, res) => {
  const { name, color } = req.body.data.attributes;

  const existingTag = await tagModel.findOne({ name: name });
  if (existingTag) {
    return res
      .status(400)
      .send({ errors: [{ detail: "TThe tag name is already taken" }] });
  }
  const newTag = new tagModel({
    name: name,
    color: color,
    created_at: Date.now(),
    updated_at: Date.now(),
  });
  await newTag.save();
  const sentData = {
    data: {
      type: "tags",
      id: newTag.id,
      attributes: {
        ...newTag._doc,
      },
    },
  };
  return res.status(201).send(sentData);
};

export const editTagRoute = async (req, res) => {
  const tagId = req.params.id;
  const { name, color } = req.body.data.attributes;

  if (!name) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The name is required" }] });
  }

  const foundTag = await tagModel.findById(tagId);
  if (!foundTag) {
    return res.status(400).json({ errors: [{ detail: "No tag was found" }] });
  }
  const existingTagsWithName = await tagModel.find({
    name: name,
    _id: { $ne: tagId },
  });
  if (existingTagsWithName.length > 0) {
    return res
      .status(400)
      .send({ errors: [{ detail: "Already exists a tag with this name" }] });
  }
  const updateTag = await tagModel.updateOne(
    { _id: tagId },
    {
      name: name,
      color: color,
      created_at: Date.now(),
      updated_at: Date.now(),
    }
  );

  const sentData = {
    data: {
      type: "tags",
      id: tagId,
      attributes: {
        ...updateTag._doc,
      },
    },
  };
  return res.status(200).send(sentData);
};

export const deleteTagRoute = async (req, res) => {
  const toDeleteTag = await tagModel.findById(req.params.id);

  if (toDeleteTag.items.length > 0) {
    return res.status(400).send({
      errors: [
        { title: "The tag has items attached and it can not be deleted" },
      ],
    });
  }

  try {
    await tagModel.deleteOne({ _id: toDeleteTag._id });
    res.sendStatus(204);
  } catch (err) {
    console.error(err);
  }
};
```

------------------------------------------------------------------------------------

File: server/src/services/uploads/index.js

Code for file:

```
import dotenv from "dotenv";
import { itemModel } from "../../schemas/item.schema";
import { userModel } from "../../schemas/user.schema";

dotenv.config();

export const setUserProfileImageRoute = async (randomId, req, res) => {
  const id = req.params.id;

  if (!req.file) {
    return res.status(400).send({ message: "No image was set" });
  } else {
    const foundUser = await userModel.findById(id);
    if (!foundUser) {
      return res.status(400).send({ message: "No user found" });
    } else {
      const image = req.file;
      const addProfilePicture = await userModel.updateOne(
        { _id: foundUser.id },
        {
          profile_image: `${process.env.APP_URL_API}/public/images/users/${id}/${randomId}-${image.originalname}`,
        }
      );
      const sentData = {
        url: `${process.env.APP_URL_API}/public/images/users/${id}/${randomId}-${image.originalname}`,
      };
      return res.status(201).send(sentData);
    }
  }
};

export const setItemImage = async (randomId, req, res) => {
  const id = req.params.id;

  if (!req.file) {
    return res.status(400).send({ message: "No image was set" });
  } else {
    const foundItem = await itemModel.findById(id);
    if (!foundItem) {
      return res.status(400).send({ message: "No item found" });
    } else {
      const image = req.file;
      const addImage = await itemModel.updateOne(
        { _id: foundItem.id },
        {
          image: `${process.env.APP_URL_API}/public/images/items/${id}/${randomId}-${image.originalname}`,
        }
      );
      const sentData = {
        url: `${process.env.APP_URL_API}/public/images/items/${id}/${randomId}-${image.originalname}`,
      };
      return res.status(201).send(sentData);
    }
  }
};
```

------------------------------------------------------------------------------------

File: server/src/services/users/index.js

Code for file:

```
import bcrypt from "bcrypt";
import dotenv from "dotenv";
import { userModel } from "../../schemas/user.schema.js";
import { roleModel } from "../../schemas/role.schema.js";
import { permissionModel } from "../../schemas/permission.schema.js";

dotenv.config();

const validateEmail = (inputText) => {
  var mailformat = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (inputText.match(mailformat)) {
    return true;
  } else {
    return false;
  }
};

export const getUsersRoute = async (req, res) => {
  let usersObjectArray = [];
  let rolesObjectArray = [];
  let permissionsObjectArray = [];
  let options = [];

  if (req.query.include) {
    options = req.query.include.split(",");
  }

  // pagination
  let paginationSize = null;
  let pageNumber = null;
  if (req.query.page) {
    if (req.query.page.number) {
      pageNumber = +req.query.page.number;
    }
    if (req.query.page.size) {
      paginationSize = +req.query.page.size;
    }
  }

  // filtering
  let filters = {};
  if (req.query.filter) {
    filters = req.query.filter;
  }

  //sorting
  let sortValue;
  if (req.query.sort) {
    sortValue = req.query.sort;
  }

  // choose fields
  let fieldsUser;
  let fieldsRole;
  let fieldsPerms;
  if (req.query.fields) {
    if (req.query.fields.users) {
      fieldsUser = req.query.fields.users.split(",");
    }
    if (req.query.fields.roles) {
      fieldsRole = req.query.fields.roles.split(",");
    }
    if (req.query.fields.permissions) {
      fieldsPerms = req.query.fields.permissions.split(",");
    }
  }

  const allUsers = await userModel
    .find(filters)
    .populate("role")
    .select(fieldsUser)
    .limit(paginationSize)
    .skip((pageNumber - 1) * paginationSize)
    .sort(sortValue);

  let jsonArrayUsers = {};
  usersObjectArray = await Promise.all(
    allUsers.map(async (element) => {
      const role = await roleModel.findOne({ _id: element.role });
      let relObj = {
        roles: {
          data: [
            {
              type: "roles",
              id: role.id,
            },
          ],
        },
      };
      let jsonObj = {
        type: "users",
        id: element.id,
        attributes: {
          ...element._doc,
        },
        relationships: relObj,
      };
      delete jsonObj.attributes.password;
      return (jsonArrayUsers = { ...jsonArrayUsers, ...jsonObj });
    })
  );

  if (options.length > 0) {
    if (options.find((el) => el == "roles")) {
      const allRoles = await roleModel.find().select(fieldsRole);
      let jsonArrayRoles = {};
      rolesObjectArray = allRoles.map((element) => {
        let jsonObj = {
          type: "roles",
          id: element.id,
          attributes: {
            ...element._doc,
          },
        };
        return (jsonArrayRoles = { ...jsonArrayRoles, ...jsonObj });
      });
    }
    if (options.find((el) => el == "roles.permissions")) {
      const allPermissions = await permissionModel.find().select(fieldsPerms);
      let jsonArrayRoles = {};
      permissionsObjectArray = allPermissions.map((element) => {
        let jsonObj = {
          type: "permissions",
          id: element.id,
          attributes: {
            ...element.doc,
          },
        };
        return (jsonArrayRoles = { ...jsonArrayRoles, ...jsonObj });
      });
    }
  }

  const sentData = {
    data: [...usersObjectArray],
    included: [...rolesObjectArray, ...permissionsObjectArray],
  };
  res.status(200).send(sentData);
};

export const getUserRoute = async (req, res) => {
  let includedDataRoles;
  let includedDataPermissions = [];
  let options = [];

  const userId = req.params.id;
  if (req.query.include) {
    options = req.query.include.split(",");
  }

  let fieldsUser;
  let fieldsRole;
  let fieldsPerms;
  let fieldObj = {};
  if (req.query.fields) {
    if (req.query.fields.users) {
      fieldsUser = req.query.fields.users.split(",");
    }
    if (req.query.fields.roles) {
      fieldsRole = req.query.fields.roles.split(",");
    }
    if (req.query.fields.permissions) {
      fieldsPerms = req.query.fields.permissions.split(",");
    }
  }

  const user = await userModel
    .findById(userId)
    .populate("role")
    .select(fieldsUser);
  const role = await roleModel
    .findOne({ _id: user.role })
    .populate("permissions")
    .select(fieldsRole);
  let userPermissions = await permissionModel
    .find({ _id: { $in: role["permissions"] } })
    .select(fieldsPerms);

  if (fieldsRole) {
    fieldObj = {
      links: {
        self: `${process.env.APP_URL_API}/${role.id}/relationships/roles`,
        related: `${process.env.APP_URL_API}/${role.id}/roles`,
      },
    };
  }

  let sentData = {
    type: "users",
    id: userId,
    attributes: {
      ...user._doc,
    },
  };
  delete sentData.attributes.password;

  if (options.length > 0) {
    if (options.find((el) => el == "roles")) {
      sentData = {
        ...sentData,
        relationships: {
          roles: {
            data: [
              {
                type: "roles",
                id: role.id,
              },
            ],
          },
        },
      };
      includedDataRoles = {
        type: "roles",
        id: role.id,
        attributes: {
          ...role._doc,
        },
      };
    }
    if (options.find((el) => el == "roles.permissions")) {
      let jsonArray = {};
      includedDataPermissions = userPermissions.map((element) => {
        let jsonObj = {
          type: "permissions",
          id: element.id,
          attributes: {
            name: element.name,
            ...element._doc,
          },
        };
        return (jsonArray = { ...jsonArray, ...jsonObj });
      });
    }
  }
  const finalData = {
    data: { ...sentData },
    relationships: { ...fieldObj },
    included: [{ ...includedDataRoles }, ...includedDataPermissions],
  };
  return res.status(200).send(finalData);
};

export const createUserRoute = async (req, res) => {
  const { name, email, profile_image, password, password_confirmation } =
    req.body.data.attributes;
  const roleId = req.body.data.relationships.roles.data[0].id;
  if (!name) {
    return res
      .status(400)
      .json({ errors: [{ detail: "The name field is required" }] });
  }
  if (!email) {
    return res
      .status(400)
      .json({ errors: [{ detail: "The email field is required" }] });
  }
  if (!roleId) {
    return res
      .status(400)
      .json({ errors: [{ detail: "The role field is required" }] });
  }
  if (!password) {
    return res
      .status(400)
      .json({ errors: [{ detail: "The password field is required" }] });
  }
  if (validateEmail(email) === false) {
    return res
      .status(400)
      .json({ errors: [{ detail: "The email is not valid" }] });
  }

  let foundUser = await userModel.findOne({ email: email });
  if (foundUser) {
    return res
      .status(400)
      .json({ message: "The email has already been taken" });
  }

  // check password to exist and be at least 8 characters long
  if (!password || password.length < 8) {
    return res
      .status(400)
      .json({ message: "Password must be at least 8 characters long." });
  }
  if (password != password_confirmation) {
    return res
      .status(400)
      .json({ message: "Password and password confirmation must match" });
  }

  // hash password to save in db
  const salt = await bcrypt.genSalt(10);
  const hashPassword = await bcrypt.hash(password, salt);

  const role = await roleModel.findOne({ _id: roleId });
  const newUser = new userModel({
    name: name,
    email: email,
    password: hashPassword,
    profile_image: `${process.env.APP_URL_API}${profile_image}`,
    created_at: Date.now(),
    updated_at: Date.now(),
    role: roleId,
  });
  await newUser.save();

  await roleModel.updateOne(
    { _id: role._id },
    { users: [...role.users, newUser._id] }
  );

  const setData = {
    data: {
      type: "users",
      id: newUser.id,
      attributes: {
        ...newUser._doc,
      },
      relationships: {
        roles: {
          links: {
            self: `${process.env.APP_URL_API}/${roleId}/relationships/roles`,
            related: `${process.env.APP_URL_API}/${roleId}/roles`,
          },
        },
      },
    },
  };
  return res.status(201).send(setData);
};

export const editUserRoute = async (req, res) => {
  const foundUser = await userModel.findById(req.params.id);

  const { name, email, profile_image } = req.body.data.attributes;
  let roleId;
  let oldRole = await roleModel.findOne({ _id: foundUser.role });
  if (req.body.data.relationships) {
    roleId = await req.body.data.relationships.roles.data[0].id;
  } else {
    roleId = oldRole._id;
  }

  if (!foundUser) {
    return res.status(400).json({ errors: [{ detail: "Wrong route" }] });
  }

  let foundUserWithEmail = await userModel.findOne({ email: email });
  if (foundUserWithEmail && foundUserWithEmail.id !== foundUser.id) {
    return res
      .status(400)
      .json({ errors: [{ detail: "The email has already been taken" }] });
  }

  const updatedUser = await userModel.updateOne(
    { _id: foundUser._id },
    { name: name, email: email, profile_image: profile_image, role: roleId }
  );

  if (oldRole._id != roleId) {
    // the role was changed
    // remove the user from the oldRole
    const results = oldRole.users.filter(
      (value) => !value.equals(foundUser._id)
    );
    await roleModel.updateOne({ _id: oldRole._id }, { users: [...results] });
    // update new role with users
    const newRole = await roleModel.findById(roleId);
    await roleModel.updateOne(
      { _id: roleId },
      { users: [...newRole.users, foundUser._id] }
    );
  }

  const sentData = {
    data: "users",
    id: foundUser.id,
    attributes: {
      ...updatedUser._doc,
    },
  };
  return res.status(200).send(sentData);
};

export const deleteUserRoute = async (req, res) => {
  // here should be verification if demo and other stuff?
  const toDeleteUser = await userModel.findById(req.params.id);

  if (!toDeleteUser) {
    return res
      .status(400)
      .send({ errors: [{ detail: "The user does not exist" }] });
  } else {
    try {
      const role = await roleModel.findById(toDeleteUser.role);
      const results = role.users.filter(
        (value) => !value.equals(toDeleteUser._id)
      );
      await roleModel.updateOne({ _id: role._id }, { users: [...results] });
      await userModel.deleteOne({ _id: toDeleteUser._id });
      res.sendStatus(204);
    } catch (err) {
      console.error(err);
    }
  }
};
```

------------------------------------------------------------------------------------

File: server/src/services/wallet/index.js

Code for file:

```
import Web3 from "web3";
import { userModel } from "../../schemas/user.schema.js";

const web3 = new Web3(process.env.ETHEREUM_RPC_URL);

export const connectWallet = async (userId, walletAddress) => {
  const user = await userModel.findByIdAndUpdate(
    userId,
    { walletAddress },
    { new: true }
  );
  return user;
};

export const getTokenBalance = async (walletAddress) => {
  const contract = new web3.eth.Contract(ABI, PROS_TOKEN_ADDRESS);
  const balance = await contract.methods.balanceOf(walletAddress).call();
  return web3.utils.fromWei(balance, "ether");
};

export const updateUserTokenBalance = async (userId) => {
  const user = await userModel.findById(userId);
  const balance = await getTokenBalance(user.walletAddress);
  user.prosTokenBalance = balance;
  await user.save();
  return user;
};
```

------------------------------------------------------------------------------------

File: server/src/index.js

Code for file:

```
import express from "express";
import http from "http";
import bodyParser from "body-parser";
import cors from "cors";
import dotenv from "dotenv";
import passport from "./passport.js";
import path from "path";
import { fileURLToPath } from "url";
import routes from "./routes/index.js";
import { dbConnect } from "./mongoose/index.js";
import cron from "node-cron";
import ReseedAction from "./mongoose/RessedAction.js";
import { initializeChat } from "./services/chat/index.js";
import cookieParser from "cookie-parser";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load environment variables from the root .env file
dotenv.config({ path: path.join(__dirname, "..", "..", ".env") });

const PORT = process.env.PORT || 8080;
const app = express();
const server = http.createServer(app);

const isDev = process.env.NODE_ENV === "development";

const whitelist = [
  isDev ? process.env.APP_URL_CLIENT_DEV : process.env.APP_URL_CLIENT_PROD,
  isDev
    ? process.env.APP_URL_DASHBOARD_DEV
    : process.env.APP_URL_DASHBOARD_PROD,
  isDev ? process.env.APP_URL_VR_DEV : process.env.APP_URL_VR_PROD,
  isDev ? process.env.APP_URL_API_DEV : process.env.APP_URL_API_PROD,
  "http://localhost:3000", // For local development
];

const corsOptions = {
  origin: function (origin, callback) {
    if (!origin || whitelist.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error("Not allowed by CORS"));
    }
  },
  credentials: true,
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
  exposedHeaders: ["set-cookie"],
};

const startServer = async () => {
  try {
    await dbConnect();

    app.use(cors(corsOptions));
    app.use(
      bodyParser.json({ type: "application/vnd.api+json", strict: false })
    );
    app.use(express.json());
    app.use(express.urlencoded({ extended: true }));
    app.use(cookieParser());
    app.use(passport.initialize());

    app.get("/health", (req, res) => {
      res.status(200).json({ status: "OK", message: "Server is running" });
    });

    app.use("/api", routes);

    app.use(express.static(path.join(__dirname, "../../homepage/build")));

    app.get("*", (req, res) => {
      const hostname = req.hostname;
      const frontendUrl = isDev
        ? process.env.APP_URL_CLIENT_DEV
        : process.env.APP_URL_CLIENT_PROD;
      const isMainDomain =
        hostname === frontendUrl || hostname.endsWith("." + frontendUrl);

      if (isMainDomain) {
        res.sendFile(path.join(__dirname, "../../homepage/build/index.html"));
      } else {
        res.status(404).json({ message: "Not found" });
      }
    });

    if (process.env.SCHEDULE_HOUR) {
      cron.schedule(`0 */${process.env.SCHEDULE_HOUR} * * *`, () => {
        ReseedAction();
      });
    }

    initializeChat(server);

    app.use((err, req, res, next) => {
      console.error("Error:", err);
      res.status(err.status || 500).json({
        message: err.message || "Internal Server Error",
        stack: isDev ? err.stack : "🥞",
      });
    });

    server.listen(PORT, () => {
      console.log(`Server listening on port ${PORT}`);
      console.log("Environment:", process.env.NODE_ENV);
      console.log("DB_LINK:", process.env.DB_LINK ? "Set" : "Not set");
      console.log(
        "APP_URL_CLIENT:",
        isDev ? process.env.APP_URL_CLIENT_DEV : process.env.APP_URL_CLIENT_PROD
      );
      console.log("CORS Whitelist:", whitelist);
      console.log("API Base URL:", `http://localhost:${PORT}/api`);
    });
  } catch (error) {
    console.error("Failed to start the server:", error);
    process.exit(1);
  }
};

startServer();
```

------------------------------------------------------------------------------------

File: server/src/passport.js

Code for file:

```
import { ExtractJwt } from "passport-jwt";
import passportJWT from "passport-jwt";
import dotenv from "dotenv";
import passport from "passport";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

import { userModel } from "./schemas/user.schema.js";

const JWTStrategy = passportJWT.Strategy;
dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const publicKeyPath = path.join(__dirname, "../config/keys/ed25519-public.key");
const publicKey = fs.readFileSync(publicKeyPath, "utf8");

passport.use(
  new JWTStrategy(
    {
      jwtFromRequest: ExtractJwt.fromExtractors([
        ExtractJwt.fromAuthHeaderAsBearerToken(),
        (req) => req.cookies.token,
      ]),
      secretOrKey: publicKey,
      algorithms: ["EdDSA"],
    },
    async function (jwtPayload, done) {
      try {
        const user = await userModel.findOne({ _id: jwtPayload.id });
        if (user) {
          return done(null, user);
        } else {
          return done(null, false);
        }
      } catch (error) {
        return done(error, false);
      }
    }
  )
);

export default passport;
```

------------------------------------------------------------------------------------

File: server/.env

Code for file:

```
# Database Configuration
DB_HOST=db-mongodb-nyc1-83629-6a0bd76f.mongo.ondigitalocean.com
DB_PORT=27017
DB_USER=doapps-601b68d4-8bd7-42cf-9f41-46f8be378f6d
DB_PASSWORD=LAIs9k01dp4762q5
DB_NAME=admin
DB_LINK=mongodb+srv://doapps-601b68d4-8bd7-42cf-9f41-46f8be378f6d:LAIs9k01dp4762q5@db-mongodb-nyc1-83629-6a0bd76f.mongo.ondigitalocean.com/admin?authSource=admin&tls=true

# JWT Configuration
JWT_SECRET="30dc73af4750af81a83562fec01d0795c88478e10b396710e6bbe019be2c0386fb048d878746ae4011e9c2dad0260252123e90e01fde066bae1a7b1f5f4920f4c7b8187e75c15c656770ce2a60534d5f123178f05f5f9254df4b34142cd7e77922db425a6132e51e004182e7332dc1624ab4b3839c535ac7b1391457d3ea9f72"

# URL Configuration
APP_URL_CLIENT_PROD=https://www.prosperadefi.com
APP_URL_API_PROD=https://api.prosperadefi.com
APP_URL_DASHBOARD_PROD=https://dashboard.prosperadefi.com
APP_URL_VR_PROD=https://vr.prosperadefi.com

APP_URL_CLIENT_DEV=http://localhost:3000
APP_URL_API_DEV=http://localhost:8080
APP_URL_DASHBOARD_DEV=http://localhost:3001
APP_URL_VR_DEV=http://localhost:3002

# Environment
NODE_ENV=development

# Mailtrap Configuration
MAILTRAP_HOST=live.smtp.mailtrap.io
MAILTRAP_PORT=587
MAILTRAP_USER=api
MAILTRAP_PASS=03215ebc81b1c94c07faa9a5bc383ba7

# Admin Configuration
ADMIN_EMAIL=zed.wolf@prosperadefi.com
ADMIN_PASSWORD=Y0uw1l1n3v3rrfigurethis0u7!
ADMIN_WALLET=0x2186381a0079f2b73546b977eC8b0197C530c006
```

------------------------------------------------------------------------------------

File: server/ecosystem.config.json

Code for file:

```
{
  "apps": [
    {
      "name": "prospera-api",
      "script": "./src/index.js",
      "cwd": "./server",
      "node_args": "--es-module-specifier-resolution=node",
      "watch": false,
      "force": true,
      "env": {
        "PORT": 8080,
        "NODE_ENV": "production",
        "DB_LINK": "mongodb+srv://doapps-601b68d4-8bd7-42cf-9f41-46f8be378f6d:LAIs9k01dp4762q5@db-mongodb-nyc1-83629-6a0bd76f.mongo.ondigitalocean.com/admin?authSource=admin&tls=true",
        "DB_HOST": "db-mongodb-nyc1-83629-6a0bd76f.mongo.ondigitalocean.com",
        "DB_PORT": "27017",
        "DB_USER": "doapps-601b68d4-8bd7-42cf-9f41-46f8be378f6d",
        "DB_PASSWORD": "LAIs9k01dp4762q5",
        "DB_NAME": "admin",
        "JWT_SECRET": "30dc73af4750af81a83562fec01d0795c88478e10b396710e6bbe019be2c0386fb048d878746ae4011e9c2dad0260252123e90e01fde066bae1a7b1f5f4920f4c7b8187e75c15c656770ce2a60534d5f123178f05f5f9254df4b34142cd7e77922db425a6132e51e004182e7332dc1624ab4b3839c535ac7b1391457d3ea9f72",
        "APP_URL_CLIENT": "https://www.prosperadefi.com",
        "APP_URL_API": "https://api.prosperadefi.com",
        "APP_URL_DASHBOARD": "https://dashboard.prosperadefi.com",
        "APP_URL_VR": "https://vr.prosperadefi.com",
        "MAILTRAP_HOST": "live.smtp.mailtrap.io",
        "MAILTRAP_PORT": "587",
        "MAILTRAP_USER": "api",
        "MAILTRAP_PASS": "03215ebc81b1c94c07faa9a5bc383ba7"
      }
    }
  ]
}

```

------------------------------------------------------------------------------------

File: server/package.json

Code for file:

```
{
  "name": "prospera-server",
  "version": "1.0.0",
  "description": "PROSPERA DeFi API Server",
  "main": "src/index.js",
  "homepage": "https://www.prosperadefi.com",
  "type": "module",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "body-parser": "^1.20.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "file-system": "^2.2.2",
    "form-data": "^4.0.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.5.4",
    "multer": "^1.4.5-lts.1",
    "mysql2": "^3.6.0",
    "node-cron": "^3.0.2",
    "nodemailer": "^6.9.4",
    "passport": "^0.6.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "pg": "^8.11.3",
    "sequelize": "^6.32.1",
    "socket.io": "^4.7.5",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "sequelize-cli": "^6.6.1"
  },
  "scripts": {
    "start": "node src/index.js",
    "start:dev": "nodemon src/index.js",
    "test": "echo \"Error: no test specified\" && exit 1",
    "seed": "node src/mongoose/seedData.js",
    "clear": "node src/mongoose/clearDbs.js"
  },
  "engines": {
    "node": ">=18"
  },
  "author": "PROSPERA Team",
  "license": "PROSPERA"
}
```

------------------------------------------------------------------------------

File: PROSPERA/package.json

Code for file:

```
{
  "name": "prospera-platform",
  "version": "1.0.0",
  "private": true,
  "workspaces": [
    "homepage",
    "server"
  ],
  "scripts": {
    "start": "node server/src/index.js",
    "start:dev": "concurrently \"npm run start:server\" \"npm run start:homepage\"",
    "start:server": "cd server && npm run start:dev",
    "start:homepage": "cd homepage && npm start",
    "build": "npm run build:homepage",
    "build:homepage": "cd homepage && npm run build",
    "install:all": "npm install && npm run install:homepage && npm run install:server",
    "install:homepage": "cd homepage && npm install",
    "install:server": "cd server && npm install",
    "lint": "npm run lint:homepage && npm run lint:server",
    "lint:homepage": "cd homepage && npm run lint",
    "lint:server": "cd server && eslint .",
    "prettify": "npm run prettify:homepage && npm run prettify:server",
    "prettify:homepage": "cd homepage && npm run prettify",
    "prettify:server": "cd server && prettier --write ."
  },
  "engines": {
    "node": ">=18"
  },
  "devDependencies": {
    "concurrently": "^8.2.1",
    "eslint": "^8.38.0",
    "prettier": "^2.8.7"
  },
  "dependencies": {
    "cookie-parser": "^1.4.6",
    "jose": "^5.7.0",
    "jsonwebtoken": "^9.0.2",
    "react-draggable": "^4.4.6",
    "web3": "^4.12.1"
  }
}
```